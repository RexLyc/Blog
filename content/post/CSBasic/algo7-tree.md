---
title: "算法导论其七：树"
date: 2021-08-27T10:30:52+08:00
categories:
- 计算机科学与技术
- 算法
tags:
- 算法系列
- 施工中
thumbnailImagePosition: left
thumbnailImage: images/thumbnail/algorithm.jpg
math: true
---
树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~
<!--more-->
# 有根树
- 实际上只是一种数据结构。用链接的方式，构造出一个树状的数据结构。
- 术语：
    - 根：有根树的最上层节点，在树中，只有这个节点是没有双亲结点的
    - 子树：树的定义是递归的，每一个节点和它的子孙节点都构成整个树的一棵子树
    - 度：每个节点的**子节点的个数**称为该节点的度，树的度取所有节点的度中最大的
    - 深度：从根节点向下逐层累加。
    - 高度：从最底层叶子节点自底向上累加。
        - 对于每个节点来说，深度和高度不一定相等，但一棵树的深度和高度相等。
    - 域：$p,left,right$，分别用于指示二叉树中的双亲、左孩子、右孩子，例如：
        - $p\[x\]= NIL$，则代表x是根。$p\[x\]\gets y$，则表示将y设置为x的双亲节点（parent缩写为p）
        - $left\[x\]= NIL$，代表x没有左孩子。$left\[x\]\gets y$，表示将y设置为x的左孩子
    - 扩展的域：$right-sibling$，指示二叉树中最近邻的右侧的兄弟（位于树的同一层的都是兄弟节点）
    - 一些常用的树：
        - 二叉树：每个节点的度$\le 2$。
        - 二叉查找（二叉搜索树）：对任何节点$t$，若左子树存在，则左子树节点值永远不大于$t$的值。若右子树存在，则右子树的值永远不小于$t$的值。
        - 平衡搜索树（AVL树）：二叉搜索树的一种，并且满足任何左子树和右子树高度之差不会大于1。
        - 满二叉树：除了叶子节点，所有节点度为2。
        - 完全二叉树：最后一层叶子节点均在左侧的满二叉树。
        - 完美二叉树：每一层均被填满的二叉树。
```cpp
// 一个典型的指针实现的
template<typename T>
struct tree_node {
    tree_node *left, *right;
    tree_node *parent;
    T val;
    
    tree_node(T val)
        : left(nullptr), right(nullptr), parent(nullptr),val(val) {}

    tree_node(T val, tree_node *left, tree_node *right, tree_node *parent)
        : val(val), left(left), right(right), parent(parent) {}
};
```
# 二叉查找树（二叉搜索树）
- 普通的有根树有什么用吗？没有。节点之间只有满足一些性质的时候，树才会显现出威力。
- 二叉查找树是查找树的一种，定义已在上一小节给出。
- 提供的核心操作：插入、删除、查询。一个良好实现的二叉查找树均能实现$O(logn)$的复杂度，$n$为树的高度。
- 其他基础操作：子树最小元素（Tree-Minimum）、子树最大元素（Tree-Maximum）、节点中序遍历下的前驱（Tree-Predecessor）、节点中序遍历下的后继（Tree-Successor）
# 跳跃表
# 红黑树
- 一种非常使用的二叉查找树的实现。保证最坏的情况下依然满足插入、删除、查询的操作时间为$O(logn)$。
- 红黑树保证没有一条路径的长度会比其他路径长出两倍，因而是接近平衡的。红黑树这种宽松的平衡条件，比AVL树的绝对平衡，在插入和删除时有性能优势，但在查询时是处于劣势的。
- 充要条件：
    1. 每个节点或者是红色，或者是黑色
    2. 根节点是黑色的
    3. 每个叶子节点（NIL）是黑色的，叶子节点不存储数据，存储节点的数据也被称为内部节点
    4. 如果一个节点是红色的，则它的孩子节点都是黑色的
    5. 对于每一个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点
- 核心操作：旋转和重新着色。目标是在树发生结构变化时，令树继续保持充要条件。
    1. 旋转：旋转操作实现时，只需要进行指针变换，左右旋转都可以在$O(1)$内完成。
    </br><center>
    ![树的旋转操作](/images/algoSeries/TreeRotate.svg)
    </center>
    
    2. 重新着色：每一次新节点插入时，以基础的二叉查找树的插入方式，将新节点插入书中，并固定的设置新节点的颜色为红色。这会导致新树不满足原有的红黑树在着色方面的要求。同理，删除节点时也会破坏原有性质。此时将会根据情况重新对部分节点进行重新上色（红色变黑色，黑色变红色）。
- 插入：在二叉查找树的插入操作的基础上，添加重新着色和旋转操作。向树$T$插入$z$的步骤如下：
    1. 自根向下查找大小适合插入$z$的位置，并插入
        - 空树则$z$直接为根
    2. 设置$z$为红色
    3. 插入的重着色和旋转：
        1. 循环2或3直到$color[p[z]]=BLACK$
        2. 父节点为左孩子
            1. 叔父节点红色：情形一，$z$上移
            2. 叔父节点黑色，$z$为右孩子：情形二，变更$z$
            3. 情形三
        3. 父节点为右孩子
            - 处理方式为镜像情况
        4. 将根赋值为黑色

    </br><center>
    ![红黑树的插入操作](/images/algoSeries/RB-Tree-INSERT.svg)
    </br>三种插入情形
    </center>
    
- 删除：删除操作也是在二叉查找树的删除操作的基础上，进行修改得来的。重新着色和旋转情况与插入相比，情况稍微复杂。从树$T$删除$z$的步骤如下：
    1. 寻找待删除节点$y$
        - 若$left[z]=nil[T]$或$right[z]=nil[T]$，则$y\gets z$
        - 否则$y\gets Tree-Successor(z)$，即实际删除中序遍历下的后继节点（后续会将当前$z$节点的值替换为后继）
    2. 计算保留节点$x$，并令$p\[x\]\gets p[y]$
        - 若$left[y]\ne nil[T]$，则$x\gets left[y]$
        - 否则$x\gets right[y]$（$x$可能为$nil[T]$）
    3. 调整$p[y]$的$left$，$right$域
        - 若$y$为根，令$x$为根
        - 若$y$不为根，且为左孩子，则$x$也为左孩子，反之亦然。
    4. 若$y\ne z$（意味着取了后继），$key[z]\gets key[y]$，即将卫星数据拷贝过去。
    5. 若$color[y]=BLACK$，进行删除的重着色和旋转（对保留下来的$x$进行）
        1. 若$x\ne root[T]$且$color[x]=BLACK$，循环处理2或3
        2. 若$x$为左孩子
            1. 若$x$的兄弟$w$为红色，情形一
            2. 若$x$的兄弟$w$为黑色，且$w$的左右孩子均为黑色，情形2
            3. 若$x$的兄弟$w$为黑色，且$w$的右孩子为黑色，情形3
            4. 情形4
        3. 若$x$为右孩子，操作均为镜像
        4. $color\[x\]\gets BLACK$
    
    </br><center>
    ![红黑树的删除操作](/images/algoSeries/RB-Tree-INSERT.svg)
    </br>四种删除情形
    </center>

- 一点理解：重新着色和旋转操作都是为了恢复红黑树的性质，对于每种情况，要看懂到能够理解违反了哪项性质，操作之后是否恢复，或者是否让子树部分恢复，并递归向上。
    - 插入的问题是两个红色相邻
    - 删除的主要问题是，包含删除节点的任意路径，黑高度降低。（另外还有其他性质被打破）
```cpp
```
# B树
# 树堆（Treap）
# 二项堆
# 斐波那契堆
# 在写作本章节时记录的博客问题
1. 在使用mathjax的\\$\\$对儿中，如果直接写\[x\]，则会显示出来一个[x]，如果想要正常显示\[x\]，需要写为\\\\[x\\\\]。
    - markdown的转义。。。有的时候真的令人无语。