---
title: "C/C++：难点总篇"
date: 2022-02-22T20:22:20+08:00
categories:
- 计算机科学与技术
- 编程语言
tags:
- C/C++系列
- 开坑篇
- 施工中
thumbnailImagePosition: left
thumbnailImage: /images/thumbnail/cpp.png
---
C/C++中有一些经常会出现的难点，也是考研功底的要点。本文致力于总结这一部分。
<!--more-->
## 高级特性
### 模板编程
1. 模板的类型
    - 类模板
    - 函数模板
    - 类型别名模板
    - 变量模板（C++17）
1. 类型萃取
    1. 参考
        - [type_traits类型萃取](https://www.cnblogs.com/gtarcoder/p/4807670.html)
1. 类型擦除
    1. 参考
        - [C++类型擦除和std::function性能测试](https://www.codercto.com/a/57707.html)

## STL
&emsp;&emsp;STL是由容器、算法、迭代器、函数对象、适配器、内存分配器这6 部分构成。其中后四部分主要是为了前两个部分服务。
### allocator分配器
1. **To Be Continue**

### 高性能IO
1. 流
    1. 参考：
        - [std::streambuf从示例到应用](https://izualzhy.cn/stream-buffer)

## 语法
### 继承和多态
1. 虚继承：当多继承的多个基类的继承体系中有相同的基类时，可能会出现公共基类成员的重复拷贝，此时会出现空间浪费，而且在使用上也容易出现二义性，因此需要使用虚继承。
    - 基本原理：使用虚继承时，类型内部会增加一个vbptr，即虚基类表指针（virtual base table pointer），该指针指向了一个虚表（virtual table），虚表中记录了vbptr与本类的偏移地址；第二项是vbptr到共有基类元素之间的偏移量。（一般来说第一个偏移地址都是0，第二项代表了vbptr地址到共有元素的差）。虚继承的类，及其子类都会保留自己这个类型的vbptr。
### 右值引用
1. 右值引用出现的原因：
    - 有一些值出现在等号右侧，是匿名变量，表面上看起来它们无法取地址，但实际上并不完全。最常见的出现场景是函数的返回值。根据该值的大小，它可能直接出现在一个寄存器内（当然就无法取地址），也可能作为一个临时变量存储函数的返回值、返回的结构体。观察汇编语言可以发现，对于一个寄存器可以存放的情况，函数返回值会**直接放在一个寄存器**中，在函数外赋值给具名变量时只需要再执行一次mov操作。如果是过长的结构体，则会直接存入到一个**指定的内存区域**，直观上看就像是写入了一个临时变量（只是没有名字，但实际上是有地址的）。如果外面使用一个变量接收全部，这片内存区域直接就是这个变量，否则就将内存中的部分内容赋值给它。在C语言中，由于没有构造和析构这种生命周期，因此这样的结果是完全可以接受的。
    - 但当C++拥有构造和析构之后，问题变得复杂了起来。如果函数返回值依然能够放在一个寄存器内则还好。如果是较长的非平凡的结构体、类，则创建这个临时变量的过程，是会调用构造，形成一个真正完整的变量，而赋值时又会调用复制构造，最后这个临时变量还会进行析构。除了性能问题外，还有一些需要讨论的：
        - 如果类型仍然能在一个寄存器内放得下，则它还是不具有内存空间，就是一个纯右值，无法被取值
        - 如果类型够大，且具有默认构造和析构，也就是什么都不做，此时它是平凡的（trivial），可以只按照C中对待结构体的方式，
        - 如果类型够大且有自定义构造和析构，它实际上是有内存空间的，是一个广义左值。返回值被完整赋值出去，则返回值本身就位于调用方内存栈空间上，是一个普通的**左值**。而如果返回值只是被部分使用，则一定会在该行语句结束后**立刻析构**，该返回值就是**将亡值**。
        - 生命周期，左值在当前代码块结束时析构，将忘值在所属语句结束时立刻析构。
        ![C++值类型](/images/Cpp/cpp-value.png)
    - 这个时候可以看出，编译器决定返回值直接写入调用方栈空间的具名变量（作为lvalue），还是存入一个匿名临时变量（作为xvalue），是由调用方的代码上下文决定的。只要不能写入一个具名变量，都可以视作是一个右值，它的生命周期将会立刻结束。因此编译器不能接受直接取地址。而且虽然C++提出了引用这一概念，但作为变量的别名，而引用实际上只是指针的语法糖，因此，传统的左值引用也无法绑定将亡值，形如
        ```cpp
        class A {};
        A getA() { return A();}
        void doSth(A &a) { /* ... */ }
        void doSth(const A &a) { /* ... */ }

        A *a = &getA();          // 编译失败，&要求左值
        A &a = getA();           // 编译失败，非常量引用需要绑定到左值
        doSth(getA());           // 显然失败
        doSth(getA());           // 虽然可以，但是不能做任何修改了
        ```
    - 从上面可以看出，如果不能单独处理右值，则每一次对右值的使用都不得不将其保存到一个左值，带来一些不必要的复制构造。或者将其绑定到常量引用，这又限制了使用方式。
    > 使用C++17及以上的版本，会比较难观察到返回值的复制构造，因为编译器已经默认支持了复制消除
1. 右值引用的目标：
    - 延长函数返回值等上下文中，右值的生命周期
    - 提供完美转发、移动语义的能力
        - 移动语义：支持移动构造函数和移动赋值函数，可以将旧对象的内部成员直接转交给新对象，旧对象内部置空。对于非函数返回值的情况，需要手动调用std::move，将其“转化”为右值（只是在类型强转static_cast）
        - 完美转发：由于右值引用也可以绑定到左值，因此作为函数参数更为灵活，使用forward结合万能引用，能够完成将输入的右值引用转发给需要左值或者右值的情况（详见下面的“万能引用”）
    > 右值引用本身显然是一个左值，因为它有名字。但它存储的内容是一个右值
1. “万能引用”：
    - 当我们有了右值引用后，貌似任何时候都可以通过std::move来使用，但是有些时候，我希望能够统一的调用一个wrapper函数，无论左值右值都能接受，而在接口内部，再来通过重载决定更底层的函数，这个时候单纯的右值引用无法满足我们。因为右值引用本身是一个左值。我们丢失了**实参的信息**。
    - 模板类型推导能力，提供了这个功能，一些貌似是右值引用的代码，在部分场合下实际是万能引用，形如
        ```cpp
        // 这里的T &&，就是万能引用
        template<typename T>
        void testPrint(T && obj) { /* ... */ }

        int a = 1;
        testPrint(a);               // T被推导为int&
        testPrint(std::move(a));    // T被推导为int&&
        // 即此时可以同时接受左值和右值
        ```
        > 传递左值推导结果是左值引用的原因，是因为当我们参数列表为T &&时，已经告知编译器，结果一定是一个引用，要么是左值引用，要么是右值引用，而此处a是左值，所以只能是左值引用
    - 引用折叠：当模板类型参数和函数形参出现引用的引用时，会对引用进行折叠
        - 对于T&&：T是左值引用仍是左值引用，T是右值引用仍是右值引用
        - 对于T&：T无论是什么，结果都是左值引用
    - 完美转发：当我们能同时拿到左值引用和右值引用时，接下来的问题就是如何将其向外传递，问题还是在于**右值引用形参本身是左值**这个问题上，因此我们需要forward
        ```cpp
        // 一种简化实现
        template<typename T>
        T&& forward(T &param) // 此处折叠的要求，调用的实参必须是左值
        {
            // 函数的返回值和此处的static_cast保持相同的引用折叠
            // 由折叠规则可知，输入是左值引用就返回左值引用，同理右值引用
            return static_cast<T&&>(param);
        }
        ```
        > std::move无法完成这个要求，因为std::move只能输出右值引用
1. 右值相关的重载和实用场景：
    ```cpp
    // --- 片段1 ---
    void print(string a) {}             // 1
    void print(string &a) {}            // 2
    void print(const string &a) {}      // 3
    void print(string &&a) {}           // 4
    void print(const string && a) {}    // 5
    // 重载错误，1/3/4/5均可
    print("hello world");

    // --- 片段2 ---
    template<typename T>
    void print(T &t){
        // 打印左值的逻辑
    }
    template<typename T>
    void print(T &&t){
        // 打印右值的逻辑
    }
    template<typename T>
    void printWrapper(T &&t){
        // 根据实参的具体引用类型，决定所使用的重载函数
        print(std::forward<T>(t));
    }
    int a = 1;
    printWrapper(a);
    printWrapper(std::move(a));
    ```
    - 当这五个函数同时实现后，调用时会出现重载错误。
    - 重载函数的选择逻辑
        - 优先选择不需要做转型的重载函数
        - 右值不会自动绑定到非常量左值引用
        - 其他情况下优先情况未确定
    - 第五种几乎没有意义，不要这么用
    - c语言的历史遗留问题：const int和int不能作为重载函数的区分
### 关键字解释
1. static关键字：
    - static修饰全局变量：普通非静态全局变量的作用域是整个程序，所有源文件都可见，静态全局变量作用域局限于一个源文件内，防止被其他源文件引用。
    - static修饰局部变量：修改了生存期。
    - static修饰函数：static普通函数，也限定在当前作用域内（即声明所在的源文件，其他文件不可见），普通函数则是extern的，被引用就可以使用。
    - static修饰类内成员：变量的生存周期变为程序开始到退出，变量和函数的作用域变为该类。
1. auto和decltype：
    - auto是根据赋值情况推断实际类型，并会根据相关规则改变类型（去除顶层的const和引用）
    - decltype只用于进行内部表达式的类型推断，不会执行内部表达式的实际计算
### 定义
1. const和*：核心原则就一句话，const默认作用于其左侧的内容，如果没有，则作用于其右侧的内容
    - 因此，为了可读性，推荐的写法是将const统一写于待修饰内容的右侧
### 指针篇
变量指针
1. C:
    1. 对0地址的使用：0地址不能解引用，但可以用于进行指针相关的地址的运算
        ```c
        // linux内核
        struct list_head {
            struct list_head *prev, *next;
        }

        struct task_struct {
            /*
            ... 
            */
            struct list_head cg_list;
        }

        // 使用时
        struct list_head list;
        struct task_struct *t = (task_struct *)( (char *)&list - ((size_t)&((task_struct *)0)->cg_list) );
        ```
函数指针
1. C：
    1. 函数签名：即函数的类型，由返回类型+参数类型列表构成。
        ```cpp
        // 函数签名为int(int,int)
        int add(int a,int b);
        ```
    2. 创建一个函数指针，需要指明指向的函数的类型。pf附近的括号必须存在，否则变为声明一个返回指针的函数。
        ```cpp
        // 局部 & 全局变量
        int (*pf) (int, int);
        pf = add;
        pf(100,100); // 使用方式1
        (*pf)(100,100); // 使用方式2
        
        // 形参定义
        void func1(int pf(int, int)); // 写法1
        void func2(int (*pf)(int, int)); // 写法2
        ```
    3. 创建别名
        ```cpp
        typedef int (*PF) (int, int);
        PF pf_2 = add; // PF定义了一个类型，和类型用法相同
        ```
    4. 函数指针作为函数返回值
        ```cpp
        // 阅读方式从自定义名称向外，func是一个函数，形参为(int)
        // 返回一个int(int, int)类型的函数指针
        int (*func1(int))(int, int);

        // 当然并不建议以上写法，过于隐晦
        PF func2(int);
        ```
2. C++：
    1. auto特性
        ```cpp
        int add(int,int);
        auto pf1 = add; // auto将会自动解析类型为函数指针
        // auto *pf1 = add; // 等价写法
        pf1(100,100); // 可以
        (*pf1)(100,100); // 可以
        ```
    2. 函数类型和函数指针类型。decltype仅解析到函数签名。
        ```cpp
        decltype(add)* pf2 = add; // 正确
        decltype(add) pf1 = add; // 错误，类型不对
        ```
    3. 形参
        ```cpp
        typedef decltype(add) func_add;
        typedef decltype(add)* funcP_add;
        void func1(func_add a);
        void func2(funcP_add a); // 错误，已有定义
        ```
    4. 成员函数指针
        ```cpp
        typedef void(A::*PF1)(); // 必须指定类型别名PF1所属的类
        PF1 pf1 = &A::func; // 必须有&
        A a;
        (a.*pf1)(); // 使用成员函数指针，需要和类型实例关联
        ```
        > 由于成员函数指针需要获取类成员函数，因此没有多态性。取到哪个类，就是其对应的实现。即使关联了其子类的实例。
3. 参考
    - [函数指针使用总结](https://www.cnblogs.com/lvchaoshun/p/7806248.html)似乎并不完全正确，**等待确认**。


## 其他坑
1. 由于C++目前越发庞大，在标准的演化过程中，可能出现一些未定义行为，在编程时需要注意
1. 内存对齐是默认发生的，可以通过__attibute__((packed))禁用，如果想要自定义则可以在aligned()中使用大于0的任何2的幂，代表需要对齐到的字节数（对象的占用大小）
1. 注意delete和delete\[\]的区别，要和new、new\[\]分别成对使用。delete虽然也会释放等量的内存，但是只会调用一次析构

## 参考
1. [【C++拾遗】 从内存布局看C++虚继承的实现原理](https://blog.csdn.net/xiejingfa/article/details/48028491)
1. [一文读懂C++右值引用和std::move](https://zhuanlan.zhihu.com/p/335994370)
1. [右值详解](https://www.cnblogs.com/jiu0821/p/7920837.html)
1. [为什么C/C++等少数编程语言要区分左右值](https://www.zhihu.com/question/428340896/answer/2913419725)
1. [完美转发 = 引用折叠 + 万能引用 + std::forward](https://zhuanlan.zhihu.com/p/369203981)