---
title: "C/C++：内存对象模型"
date: 2024-04-13T17:15:58+08:00
categories:
- 计算机科学与技术
- 编程语言
tags:
- C/C++系列
- 开坑篇
thumbnailImagePosition: left
thumbnailImage: /images/thumbnail/cpp.png
---
本文记录对C/C++内存对象模型的学习。
<!--more-->
## 术语
1. ADT：抽象数据类型模型
2. OOP

## 成员分类和对象模型
### 基础情况
数据成员有两种
1. 静态数据成员
2. 非静态数据成员

成员函数有三种
1. 静态函数
2. 非静态
3. 虚函数

当成员分类确定之后，就可以开始思考对象的内存模型。

先看一下两种未被采纳，但是仍值得参考的对象模型
1. 简单对象模型：对象内存中，存储着到所有成员（包括数据和函数）的指针，有多少个成员就有多少个指针。
2. 表格驱动对象模型：对象内存中，存储到数据成员表，到成员函数表的两个指针。其中数据成员表内按顺序排列存储着各个数据成员。成员函数表则是一系列到函数的指针。

C++真正使用的对象模型是从简单对象模型派生而来的。从成员角度来看
1. 数据成员：
    2. 对象外：静态成员
    3. 对象内：非静态存储
4. 成员函数：
    5. 对象外：静态和非静态函数，虚函数表vtbl
    6. 对象内：虚函数表指针vptr

### 考虑继承
在继承的情况下，基类的实体部分称为subobject。

这里还可以参考一下两种并未使用的对象模型
1. 在简单对象模型上改造：在对象内存储一系列指向不同基类的suboject的指针
2. 在表格驱动模型上改造：增加一个基类指针表格，并在对象内增加一个指向基类表格的指针。

以上两种方式，最大的问题是引入了过多的间接级数，而且这种级数随着继承深度加深而变深。当然也不是完全没有好处，使用指针的话，可以允许基类在某些修改情况之后，不需要对派生类进行重新编译。

1. 单继承
2. 多继承
3. 虚继承

## 布局和成本
C++对数据和操作的封装，不会带来过多的额外成本。一般来说
1. 数据成员直接内含在每一个对象内存布局中
2. 非inline成员函数只会产生一个函数实体，不会出现在对象内存布局中
3. inline成员函数，则会在每一个调用者所在的位置，产生一个函数实体。

而额外的空间和时间成本来自于两种情况。
1. 虚函数机制
2. 虚继承

### 布局顺序


## 兼容C的布局
推荐思路
1. 使用组合而非继承，即在C++内使用C类型的对象

### 兼容带来的问题
1. 在C中允许单一元素数组放在struct尾端，并借此让该类型对象拥有大小可变的数组
    ```c
    struct mumble {
        /* stuff */
        char pc[1];
    };

    // 分配空间，并拷贝字符串
    struct mumble *pmumbl = (struct mumble*) malloc(sizeof(struct mumble) + strlen(string) + 1);
    strcpy(&memple.pc, string);
    ```
    但是这个技巧在C++中不一定有效。因为不同的访问权限的数据成员（即不同的access sections），排列并没有严格限制（待确认）。