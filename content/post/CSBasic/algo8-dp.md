---
title: "算法导论其八：动态规划和贪心算法"
date: 2021-08-27T10:31:04+08:00
categories:
- 计算机科学与技术
- 算法
tags:
- 算法系列
- 施工中
thumbnailImagePosition: left
thumbnailImage: images/thumbnail/algorithm.jpg
math: true
---
动态规划可以简单的理解为带备忘录的搜索。相较于搜索，动态规划通过列出状态转移方程和边界条件，通常能够非常简明的计算出结果。贪心算法也在本章。
<!--more-->
# 动态规划
## 概述
1. 动态规划并没有一个放诸四海皆准的公式。但是总而言之，它可以分为以下几个步骤进行设计。
    1. 描述最优解的结构（也是最考验思维的一步，最优解由哪些值计算得出）
    2. 递归定义最优解的值（状态转移方程）
    3. 自底向上的计算最优解所需要的值
    4. 由计算出的各个值构造出最终结果
2. 优化：普通的动态规划并没有本质上比搜索强太多，即不一定能降低复杂度，可能只是常数上的一个改变。动态规划实际也有很多优化技巧。
## 最优子结构
## 重叠子问题
## 优化
1. 空间优化：当你编程的时候发现，动态规划的状态存储数据结构中，有那么几个维度，只受到少数状态值（或者是最近几次状态值的影响），那么就可以进行空间优化。一般可以将数据结构降低一个$n$的指数级别。
    - 例如：$f(i,j)=max_{0<j<n}\\{f(i-1,j)+h_{\mathrm{某种代价}}(i,j)\\}$。这里面，i所在的维度，显然没有存储的必要，在可以的情况下应当予以删除。
    - 优化不需要过早，为了思路清晰，空间多一些一般无所谓。
2. 时间优化：这是动态规划提升难度的地方。计划在后续的系列中，结合实际题目进行更新吧。
## 例子
### 装配线调度
1. 问题描述：
    - 在工厂内经常有装配线用于组装一个产品，一条装配线上有多个装配站，当一个产品经过一个装配线上的所有装配站后就可以出厂了。设装配线编号为$i$，设第$i$条装配线上的第$j$个装配站为$S_{i,j}$。不同装配线上的相同位置的装配站，功能相同。即$S_{1,j}$和$S_{2,j}$功能相同。将装配站$S_{i,j}$的装配用时记为$a_{i,j}$。产品进入第$i$条装配线的时间为$e_i$，离开的时间为$x_i$。
    - 不同的装配站速度可能完全不一样，即使他们是同一顺位的。而且正常情况下，装配线上的产品是不会变更装配线的，但是如果希望加快装配速度，则可以更换。将产品从$S_{i,j}$移走的时间为$t_{i,j}$。
    - 请问一个产品从开始装配到结束，最快能多快呢？（方便起见，本文接下来的讨论中，装配线数量只有两个）
1. 暴力解法：遍历所有的$2^n$种装配站的组合，计算每一种的用时。复杂度$O(2^nn)$。$j=1,2,....,n$
1. 思考步骤：
    1. 描述最优解的结构：考虑产品从起始点到装配站$S_{i,j}$的最快路线$f(S_{i,j})$。按顺序遍历所有的装配站即可。
    1. 状态转移方程：$f(S_{i,j}) \gets h(S_{1,j-1},S_{2,j-1})$。更具体的来说，$f(S_{1,j})=min(f(S_{1,j-1})+a_{1,j},\ f(S_{2,j-1})+t_{2,j-1}+a_{2,j})$。
    1. 自底向上计算：给出边界值$f(S_{1,1}) = a_{1,1} , \ f(S_{2,1}) = a_{2,1}$。
    1. 最终结果：$min(f(S_{1,n}), \ f(S_{2,n}))$。
1. 额外的话：
    1. 描述最优解的结构，这是非常考验算法能力的一步。说太多的方法论都是空话，这个东西就是多看多练就好了。
    1. 有一种值得一试的思路，就是从递归的反向思维出发。正常是计算当前的用时，然后递归调用接下来去往哪个装配站。而动态规划的解法恰恰相反，是从当前装配站的来源来考虑。
### 矩阵链乘法
1. 描述：给定$n$个要相乘的矩阵构成的序列$<A_1,A_2,...,A_n>$。计算乘积，$A_1 A_2 \cdots A_n$。如何让计算尽量快。
    - 更快的计算：在这里不考虑对矩阵乘法的专门优化。只考虑一个最优的矩阵乘顺序。即如何添加括号，使得总的乘法计算数量尽量小。
1. 暴力解法：将矩阵乘序列分为两个部分，最后计算两部分的乘积。递归的，暴力进行这种划分方式的搜索。你可以试着推导一下这个的复杂度，简单来说，是指数级别的，$\Omega(2^n)$
1. 思考步骤：
    1. 描述最优解结构：对于长度为$l$的矩阵乘序列，$A_i A_{i+1} \cdots A_{i+l} $序列，其最优解包含于$A_i A_{i+1} \cdots A_k \cdot A_{k+1} \cdots A_{i+l}$。遍历$k \in (i,i+l)$，即可获得最优解。
    1. 状态转移方程。$f(A,i,i+l) = min_{i<k<i+l-1}\\{$
        $f(A,i,k)+f(A,k+1,i+l)$
        $+ROW(A_i)*COL(A_k)^2*COL(A_{i+l})\\}$
    1. 自底向上计算：给出边界值，即所有的$l=1$的矩阵乘序列，就是两个矩阵相乘所需要的乘法数量，先算出来这部分。然后分别遍历$l,k$。
    1. 最终结果：$f(A,1,n)$
1. 额外的话：
    1. 本题的动态规划思路和暴力思路看起来非常相近，但是是有本质区别的。从另一个角度来看，动态规划利用了重叠区间的共享信息。使得最终的时间复杂度达到了$\Theta(n^2)$。
### 最长公共子序列
1. 描述：
    - 两个字符串，形如字符串a："ABCDEFGXYZ",字符串b："AZDZGZXZYZUC"。子序列指的是字符串中部分不重复的字符组成的新字符串，非要形式化的话，对原串$<a_1 a_2 \cdots a_n>$，取序列$1 \le i_1 < i_2 < \cdots < i_{k-1} < i_k \le n$，其中$k \in [0,n]$，则原串的一个子序列为$<a_{i_1} a_{i_2} \cdots a_{i_{k-1}} a_{i_k}>$。
    - 最长公共子序列就是求出两个字符串，甚至是多个字符串之间，最长的且相等的子序列。
    > 子串的要求是下标序列$i_1,i_2,\cdots,i_k$必须连续。注意子序列和子串的区分。
1. 暴力解法：枚举二者所有的子序列，从最长的开始比较是否有相等的情况。仅仅是枚举子序列就已经达到$O(2^n)$了哦。
1. 思考步骤：
    1. 描述最优子结构：令$f(i,j)$代表第一个字符串$a$包含在范围$<a_1 \cdots a_i>$内的子序列，和第二个字符串$b$包含在范围$<b_1 \cdots b_j>$。
    1. 状态转移方程：
        - 如果$a_i = b_j$：则$f(i,j)=f(i-1,j-1)+1$
        - 否则$a_i \ne b_j$：则$f(i,j)=max\\{f(i-1,j),f(i,j-1)\\}$
    1. 自底向上计算：边界情况为$f(1,1)$，分别遍历$i,j$。
    1. 最终结果：$f(length(a),length(b))$。
1. 额外的话：
    1. 从这里，我们发现，动态规划的状态转移方程，可能有多种情况，不同情况之间的状态转移可能完全不同，有的可能直接算出结果，有的需要进行$min$，$max$等操作。
### 最优二叉查找树
1. 描述：
    - 虽然通过一定的算法，我们能够构造出平衡的二叉搜索树，但是这种搜索树的搜索效率并不是最优的。假设我们需要简单的填鸭式翻译一篇文章，从中文到英文，那么我们希望频率出现最高的词汇，相对的出现在二叉搜索树的顶端，这样能够尽量减少搜索时的访问次数。因此我们需要建立的就是一棵最优二叉搜索树。
    - 形式化地，给定一个由$n$个互异的关键字组成的序列$K=<k_1,k_2,\cdots,k_n>$，且关键字有序，即$k_1 < k_2 < \cdots < k_n$。由于某些搜索的值，可能不存在于关键字序列中，因此实际上我们需要使用一套虚拟关键字序列$D=<d_0,d_1,d_2,\cdots,d_n>$，其中$d_0$代表所有小于$k_1$的值，$d_n$代表所有大于$k_n$的值。而对于$d_i \in \\{d_1,\cdots,d_{n-1}\\}$，虚拟键$d_i$代表所有位于$k_i$，$k_{i+1}$之间的值。使用关键字序列$K$，$D$建立的搜索树中，每个关键字$k_i$是一个内部节点，每个虚拟关键字$d_i$是一个叶子节点。设找到$k_i$的概率为$p_i$，找到$d_i$的概率为$q_i$，显然有$\sum{p_i}+\sum{q_i}=1$。
    - 假设搜索代价和节点深度有关，则对于一棵二叉搜索树$T$，一次搜索的期望代价为：$E[T] = \sum_{i=1}^{n}(depth_T(k_i)+1)p_i + \sum_{i=1}^{n}(depth_T(d_i)+1)q_i$ 
    </br>&emsp;&emsp;&emsp;$= 1 + \sum_{i=1}^{n}depth_T(k_i)p_i + \sum_{i=1}^{n}depth_T(d_i)q_i$
    - 如何排列$k_i$使得期望代价最小，就是寻找最优二叉搜索树。
1. 暴力解法：暴力生成所有可能的二叉搜索树的结构，计算搜索期望。这种树的数量是指数级别的，别想了。
1. 思考步骤：
    1. 描述最优子结构：
    1. 状态转移方程：
    1. 自底向上计算：
    1. 最终结果：
# 贪心算法
## 概述
## 例子
### 活动选择问题
### 哈夫曼编码
### 任务调度问题
## 扩展阅读：“拟阵”