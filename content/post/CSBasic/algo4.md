---
title: "算法导论其四：中位数和顺序统计"
date: 2021-07-24T16:13:42+08:00
categories:
- 计算机科学与技术
- 算法
tags:
- 算法系列
- 施工中
thumbnailImagePosition: left
thumbnailImage: images/thumbnail/algorithm.jpg
math: true
---
求中位数是非常经典，且有相当精妙算法的一个问题。代表了顺序统计问题的思考方式。
<!--more-->
# 问题描述
- 中位数：数组排序后，位于中点的数字（总数奇数即为一个数字，否则有2个）。
- 顺序统计问题（选择问题）：求包含n个数字的集合中的第i小的数字，$1 \le i \le n$。第i个数字也叫做第i顺序统计量。
# 思路
- 暴力想法：排序，排序之后任意顺位的数字都不是问题。复杂度$\mathrm{O}(nlogn)$。
    - 面试官：“那有没有更快的呢？”
- 优化：实际上求排序相当于获取了过多的细节。降低时间复杂度的办法就是减少信息获取。
# 同时求最大最小值
- 暴力想法：每个数字比较两次，即和存储的最大和最小值都比较。比较次数$2n-2$。
- 优化想法：成对比较，每次取两个数字，并取两个数字中的小者和当前最小值比较，大者和当前最大值比较。比较次数至多$3 \lfloor n/2 \rfloor$。
- 渐进时间$\Theta(n)$
- 为什么要这么扣：常数项其实影响很大（这里就差出去1.5倍），别让自己总是无意识的写出很暴力的算法。
# 选择问题
- 随机选择算法
    - 很好理解的一个**期望**时间复杂度为$\Theta(n)$的算法（注意期望的含义哈，有随机在里面了，还不得有点幺蛾子）
    - 思路概述：在排序章节，我们学习了随机化快速排序，其核心思想是随机选取主元，并用主元将当前片段$A[l,r]$分片（partition操作）。随机选择算法利用了这一过程，在求第i小元素时，先进行分片，可以很容易的得知当前主元的位置p，$l\le p \le r$。若$p==i$，则问题结束。否则根据p和i的大小分别选择分片的前半段和后半段进行递归。
    ```cpp
    // 代码我一定补完
    template<typename T>
    T randomizedSelect(typename std::vector<T>::iterator begin
                        , typename std::vector<T>::iterator curBegin
                        , typename std::vector<T>::iterator curEnd
                        , std::size_t i) 
    {
        
    }
    ```
- BFPRT算法
    - 这个非常炫酷的，**最坏**时间复杂度$\Theta(n)$的算法，由Blum、Floyd、Pratt、Rivest、Tarjan发明。巧妙到虽然可能写不出来，但是看过就一定能有印象（指对算法很巧妙这件事情有印象）的程度。
    - 普通分片和随机化分片的最大问题，无法保证主元选取得很好。BFPRT主要解决的就是这个问题。
    - 步骤：
        1. 将数据分为$\lceil n/5 \rceil$组，除1个组外，其他组全部是5个数。
        2. 每一组求中位数
        3. 对每一组的中位数求中位数（从第1步开始递归）
        4. 用中位数的中位数对当前数组分片，得知该中位数所在位置为k
        5. 和随机选择算法同理，比较k和选择值i，分情况递归。
    ```cpp
    // 代码我一定补完
    ```
    - 为什么是$\Theta(n)$?
        - 关键图解
        - 看一眼视频课，这里讲的比较好
        - 推导公式