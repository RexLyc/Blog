<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.87.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="李奕成">
<meta name="keywords" content="">
<meta name="description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">


<meta property="og:description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">
<meta property="og:type" content="article">
<meta property="og:title" content="算法导论其七：树">
<meta name="twitter:title" content="算法导论其七：树">
<meta property="og:url" content="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E4%B8%83%E6%A0%91/">
<meta property="twitter:url" content="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E4%B8%83%E6%A0%91/">
<meta property="og:site_name" content="奕成的个人空间">
<meta property="og:description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">
<meta name="twitter:description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2021-08-27T10:30:52">
  
  
    <meta property="article:modified_time" content="2021-08-27T10:30:52">
  
  
  
    
      <meta property="article:section" content="计算机科学与技术">
    
      <meta property="article:section" content="算法">
    
  
  
    
      <meta property="article:tag" content="算法系列">
    
      <meta property="article:tag" content="施工中">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://www.lyclife.com/images/thumbnail/algorithm.jpg">
  <meta property="twitter:image" content="https://www.lyclife.com/images/thumbnail/algorithm.jpg">





  <meta property="og:image" content="https://www.lyclife.com/images/author.jpg">
  <meta property="twitter:image" content="https://www.lyclife.com/images/author.jpg">


    
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\[\[", "\]\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };
</script>
<script src="https://www.lyclife.com/scripts/polyfill.min.js"></script>
<script
  id="MathJax-script"
  async
  src="https://www.lyclife.com/scripts/MathJax-3.2.0/es5/tex-mml-chtml.js"
></script>

    <title>算法导论其七：树</title>

    <link rel="icon" href="https://www.lyclife.com/images/favicon.png">
    

    

    <link rel="canonical" href="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E4%B8%83%E6%A0%91/">

    
    <link href="https://www.lyclife.com/scripts/Font-Awesome-4.7.0/css/font-awesome.css" rel="stylesheet">
    
    
    <link href="https://www.lyclife.com/scripts/fancybox-2.1.7/source/jquery.fancybox.css" rel="stylesheet">
    <link href="https://www.lyclife.com/scripts/fancybox-2.1.7/source/helpers/jquery.fancybox-thumbs.css" rel="stylesheet">
    
    
    <link rel="stylesheet" href="https://www.lyclife.com/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://www.lyclife.com/">奕成的个人空间</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://www.lyclife.com/#about">
    
    
    
      
        <img class="header-picture" src="https://www.lyclife.com/images/author.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://www.lyclife.com/#about">
          <img class="sidebar-profile-picture" src="https://www.lyclife.com/images/author.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">李奕成</h4>
        
          <h5 class="sidebar-profile-bio">每天都是最好的一天</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/RexLyc" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/images/wechat.jpg">
    
      <i class="sidebar-button-icon fa fa-lg fa-wechat"></i>
      
      <span class="sidebar-button-desc">微信</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      算法导论其七：树
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-08-27T10:30:52&#43;08:00">
        
  八月 27, 2021

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://www.lyclife.com/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%8e%e6%8a%80%e6%9c%af">计算机科学与技术</a>, 
    
      <a class="category-link" href="https://www.lyclife.com/categories/%e7%ae%97%e6%b3%95">算法</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~</p>
<h1 id="有根树">有根树</h1>
<ul>
<li>实际上只是一种数据结构。用链接的方式，构造出一个树状的数据结构。</li>
<li>术语：
<ul>
<li>根：有根树的最上层节点，在树中，只有这个节点是没有双亲结点的</li>
<li>子树：树的定义是递归的，每一个节点和它的子孙节点都构成整个树的一棵子树</li>
<li>度：每个节点的<strong>子节点的个数</strong>称为该节点的度，树的度取所有节点的度中最大的</li>
<li>深度：从根节点向下逐层累加。</li>
<li>高度：从最底层叶子节点自底向上累加。
<ul>
<li>对于每个节点来说，深度和高度不一定相等，但一棵树的深度和高度相等。</li>
</ul>
</li>
<li>域：$p,left,right$，分别用于指示二叉树中的双亲、左孩子、右孩子，例如：
<ul>
<li>$p[x]= NIL$，则代表x是根。$p[x]\gets y$，则表示将y设置为x的双亲节点（parent缩写为p）</li>
<li>$left[x]= NIL$，代表x没有左孩子。$left[x]\gets y$，表示将y设置为x的左孩子</li>
</ul>
</li>
<li>扩展的域：$right-sibling$，指示二叉树中最近邻的右侧的兄弟（位于树的同一层的都是兄弟节点）</li>
<li>一些常用的树：
<ul>
<li>二叉树：每个节点的度$\le 2$。</li>
<li>二叉查找（二叉搜索树）：对任何节点$t$，若左子树存在，则左子树节点值永远不大于$t$的值。若右子树存在，则右子树的值永远不小于$t$的值。</li>
<li>平衡搜索树（AVL树）：二叉搜索树的一种，并且满足任何左子树和右子树高度之差不会大于1。</li>
<li>满二叉树：除了叶子节点，所有节点度为2。</li>
<li>完全二叉树：最后一层叶子节点均在左侧的满二叉树。</li>
<li>完美二叉树：每一层均被填满的二叉树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 一个典型的指针实现的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">tree_node</span> {
    tree_node <span style="color:#f92672">*</span>left, <span style="color:#f92672">*</span>right;
    tree_node <span style="color:#f92672">*</span>parent;
    T val;
    
    tree_node(T val)
        <span style="color:#f92672">:</span> left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>), parent(<span style="color:#66d9ef">nullptr</span>),val(val) {}

    tree_node(T val, tree_node <span style="color:#f92672">*</span>left, tree_node <span style="color:#f92672">*</span>right, tree_node <span style="color:#f92672">*</span>parent)
        <span style="color:#f92672">:</span> val(val), left(left), right(right), parent(parent) {}
};
</code></pre></div><h1 id="二叉查找树二叉搜索树">二叉查找树（二叉搜索树）</h1>
<ul>
<li>普通的有根树有什么用吗？没有。节点之间只有满足一些性质的时候，树才会显现出威力。</li>
<li>二叉查找树是查找树的一种，定义已在上一小节给出。</li>
<li>提供的核心操作：插入、删除、查询。一个良好实现的二叉查找树均能实现$O(logn)$的复杂度，$n$为树的高度。</li>
<li>其他基础操作：子树最小元素（Tree-Minimum）、子树最大元素（Tree-Maximum）、节点中序遍历下的前驱（Tree-Predecessor）、节点中序遍历下的后继（Tree-Successor）</li>
<li>常见的实用二叉搜索树：
<ol>
<li>AVL树：得名于其发明者的名字（ Adelson-Velskii 以及 Landis）。AVL树是最先发明的严格自平衡二叉查找树，其任何节点的左右子树高度差绝对值小于1。</li>
<li>红黑树：下面就讲啦。</li>
</ol>
</li>
</ul>
<h1 id="红黑树">红黑树</h1>
<ul>
<li>
<p>一种非常使用的二叉查找树的实现。保证最坏的情况下依然满足插入、删除、查询的操作时间为$O(logn)$。</p>
</li>
<li>
<p>红黑树保证没有一条路径的长度会比其他路径长出两倍，因而是接近平衡的。红黑树这种宽松的平衡条件，比AVL树的绝对平衡，在插入和删除时有性能优势，但在查询时是处于劣势的。</p>
</li>
<li>
<p>充要条件：</p>
<ol>
<li>每个节点或者是红色，或者是黑色</li>
<li>根节点是黑色的</li>
<li>每个叶子节点（NIL）是黑色的，叶子节点不存储数据，存储节点的数据也被称为内部节点</li>
<li>如果一个节点是红色的，则它的孩子节点都是黑色的</li>
<li>对于每一个节点，从该节点到其子孙叶子节点的所有路径上包含相同数目的黑节点</li>
</ol>
</li>
<li>
<p>核心操作：旋转和重新着色。目标是在树发生结构变化时，令树继续保持充要条件。</p>
<ol>
<li>旋转：旋转操作实现时，只需要进行指针变换，左右旋转都可以在$O(1)$内完成。
</br><center>
<img src="https://www.lyclife.com/images/algoSeries/TreeRotate.svg" alt="树的旋转操作"></li>
</ol>
  </center>
<ol start="2">
<li>重新着色：每一次新节点插入时，以基础的二叉查找树的插入方式，将新节点插入书中，并固定的设置新节点的颜色为红色。这会导致新树不满足原有的红黑树在着色方面的要求。同理，删除节点时也会破坏原有性质。此时将会根据情况重新对部分节点进行重新上色（红色变黑色，黑色变红色）。</li>
</ol>
</li>
<li>
<p>插入：在二叉查找树的插入操作的基础上，添加重新着色和旋转操作。向树$T$插入$z$的步骤如下：</p>
<ol>
<li>自根向下查找大小适合插入$z$的位置，并插入
<ul>
<li>空树则$z$直接为根</li>
</ul>
</li>
<li>设置$z$为红色</li>
<li>插入的重着色和旋转：
<ol>
<li>循环2或3直到$color[p[z]]=BLACK$</li>
<li>父节点为左孩子
<ol>
<li>叔父节点红色：情形一，$z$上移</li>
<li>叔父节点黑色，$z$为右孩子：情形二，变更$z$</li>
<li>情形三</li>
</ol>
</li>
<li>父节点为右孩子
<ul>
<li>处理方式为镜像情况</li>
</ul>
</li>
<li>将根赋值为黑色</li>
</ol>
</li>
</ol>
<p></br><center>
<img src="https://www.lyclife.com/images/algoSeries/RB-Tree-INSERT.svg" alt="红黑树的插入操作">
</br>三种插入情形</p>
  </center>
</li>
<li>
<p>删除：删除操作也是在二叉查找树的删除操作的基础上，进行修改得来的。重新着色和旋转情况与插入相比，情况稍微复杂。从树$T$删除$z$的步骤如下：</p>
<ol>
<li>寻找待删除节点$y$
<ul>
<li>若$left[z]=nil[T]$或$right[z]=nil[T]$，则$y\gets z$</li>
<li>否则$y\gets Tree-Successor(z)$，即实际删除中序遍历下的后继节点（后续会将当前$z$节点的值替换为后继）</li>
</ul>
</li>
<li>计算保留节点$x$，$x$将会代替$y$的位置，并令$p[x]\gets p[y]$
<ul>
<li>若$left[y]\ne nil[T]$，则$x\gets left[y]$</li>
<li>否则$x\gets right[y]$（$x$可能为$nil[T]$）</li>
</ul>
</li>
<li>调整$p[y]$的$left$，$right$域
<ul>
<li>若$y$为根，令$x$为根</li>
<li>若$y$不为根，且为左孩子，则$x$也为左孩子，反之亦然。</li>
</ul>
</li>
<li>若$y\ne z$（意味着取了后继），$key[z]\gets key[y]$，即将卫星数据拷贝过去。</li>
<li>若$color[y]=BLACK$，进行删除的重着色和旋转（对保留下来的$x$进行）
<ol>
<li>若$x\ne root[T]$且$color[x]=BLACK$，循环处理2或3</li>
<li>若$x$为左孩子
<ol>
<li>若$x$的兄弟$w$为红色，情形一</li>
<li>若$x$的兄弟$w$为黑色，且$w$的左右孩子均为黑色，情形2</li>
<li>若$x$的兄弟$w$为黑色，且$w$的右孩子为黑色，情形3</li>
<li>情形4（C取A原色）</li>
</ol>
</li>
<li>若$x$为右孩子，操作均为镜像</li>
<li>$color[x]\gets BLACK$</li>
</ol>
</li>
</ol>
<p></br><center>
<img src="https://www.lyclife.com/images/algoSeries/RB-Tree-Delete.svg" alt="红黑树的删除操作">
</br>四种删除情形(绿色代表该节点颜色无所谓)
</br>注：情形4中C取A色，D色不变</p>
  </center>
</li>
<li>
<p>关于插入和删除の一点理解：重新着色和旋转操作都是为了恢复红黑树的性质，对于每种情况，要看懂到能够理解违反了哪项性质，操作之后是否恢复，或者是否让子树部分恢复，并递归向上。</p>
<ul>
<li>插入的问题是两个红色相邻</li>
<li>删除的主要问题是，<strong>包含删除节点的任意路径，黑高度降低</strong>。（另外还可能有其他性质被打破）
<ul>
<li>这里主要需要思考清楚的是情形一和二，这两者不会重复循环出现：若是从情形一到情形二，则将会很快退出循环；若是从情形二到情形一，则至多为二到一再到二，并退出</li>
<li>一旦进入情形三、四，将会很快退出</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 这玩意儿能写好久
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> lyc_algorithm {

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binary_tree_node</span> {
		binary_tree_node<span style="color:#f92672">*</span> parent;
		binary_tree_node<span style="color:#f92672">*</span> left;
		binary_tree_node<span style="color:#f92672">*</span> right;
		T data;
		<span style="color:#75715e">// 数据存储次数
</span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>size_t times;
		binary_tree_node(binary_tree_node<span style="color:#f92672">*</span> parent
			, binary_tree_node<span style="color:#f92672">*</span> left, binary_tree_node<span style="color:#f92672">*</span> right, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data)
			<span style="color:#f92672">:</span>parent(parent), left(left), right(right), data(data),times(<span style="color:#ae81ff">1</span>) {}
		binary_tree_node()
			<span style="color:#f92672">:</span>parent(<span style="color:#66d9ef">nullptr</span>), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>),times(<span style="color:#ae81ff">0</span>) {}
		binary_tree_node(binary_tree_node<span style="color:#f92672">*</span> parent)
			<span style="color:#f92672">:</span>parent(parent), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>), times(<span style="color:#ae81ff">0</span>) {}
	};



	<span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NODE_COLOR</span> {
		RED, BLACK
	};

	std<span style="color:#f92672">::</span>string enum_trans(<span style="color:#66d9ef">const</span> NODE_COLOR<span style="color:#f92672">&amp;</span> e) {
		<span style="color:#66d9ef">switch</span> (e) {
			<span style="color:#66d9ef">case</span> NODE_COLOR<span style="color:#f92672">::</span>RED:
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;RED&#34;</span>;
			<span style="color:#66d9ef">case</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK:
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;BLACK&#34;</span>;
			<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;??&#34;</span>;
		}
	}

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binary_search_tree_node</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
		binary_search_tree_node(binary_search_tree_node<span style="color:#f92672">*</span> parent
			, binary_search_tree_node<span style="color:#f92672">*</span> left, binary_search_tree_node<span style="color:#f92672">*</span> right, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data)
			<span style="color:#f92672">:</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent, left, right, data) {}
		binary_search_tree_node()
			<span style="color:#f92672">:</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>() {}
		binary_search_tree_node(binary_search_tree_node<span style="color:#f92672">*</span> parent)
			<span style="color:#f92672">:</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent) {}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">redblack_tree_node</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
		<span style="color:#75715e">// 创建一个内部节点
</span><span style="color:#75715e"></span>		redblack_tree_node(redblack_tree_node<span style="color:#f92672">*</span> parent
			, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data,  NODE_COLOR color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED)
			<span style="color:#f92672">:</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent
				, <span style="color:#66d9ef">new</span> redblack_tree_node(<span style="color:#66d9ef">this</span>), <span style="color:#66d9ef">new</span> redblack_tree_node(<span style="color:#66d9ef">this</span>), data)
			, color(color) ,is_nil(false){}

		<span style="color:#75715e">// 创建一个无数据的叶子节点
</span><span style="color:#75715e"></span>		redblack_tree_node(redblack_tree_node<span style="color:#f92672">*</span> parent)
			<span style="color:#f92672">:</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent), color(NODE_COLOR<span style="color:#f92672">::</span>BLACK) ,is_nil(true) {}

		NODE_COLOR color;
		<span style="color:#66d9ef">bool</span> is_nil;

		<span style="color:#75715e">// 废弃：待删除节点应当直接被删除，而不是转为叶子节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">to_nil</span>() {
			<span style="color:#66d9ef">if</span> (is_nil) {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;this node is already a nil&#34;</span>);
			}
			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left)<span style="color:#f92672">-&gt;</span>is_nil)
				<span style="color:#f92672">||</span> <span style="color:#f92672">!</span>(to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right)<span style="color:#f92672">-&gt;</span>is_nil)) {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;to_nil should only apply to the node which has two nil childs&#34;</span>);
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left;
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right;
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>times <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
				is_nil <span style="color:#f92672">=</span> true;
				color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
			}
		}

		<span style="color:#75715e">// 将叶子节点转为内部节点，并自动创建新的叶子节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">to_inner</span>(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
			<span style="color:#66d9ef">if</span> (is_nil) {
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>data <span style="color:#f92672">=</span> data;
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>times <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
				is_nil <span style="color:#f92672">=</span> false;
				<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span>);
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span>);
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;this node is already a inner node&#34;</span>);
			}
		}

		<span style="color:#75715e">// 析构时删除存在的叶子孩子节点
</span><span style="color:#75715e"></span>		<span style="color:#f92672">~</span>redblack_tree_node() {
			<span style="color:#66d9ef">if</span> (binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left <span style="color:#f92672">&amp;&amp;</span> to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left)<span style="color:#f92672">-&gt;</span>is_nil) {
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left;
			}
			<span style="color:#66d9ef">if</span> (binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right <span style="color:#f92672">&amp;&amp;</span> to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right)<span style="color:#f92672">-&gt;</span>is_nil) {
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right;
			}
		}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">constexpr</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node) {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(node);
	}

	<span style="color:#75715e">// 左旋：返回左旋后新的根
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> left_rotate(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> right <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>right;
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent_parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>right) <span style="color:#75715e">// 不存在右孩子，结构不支持左旋
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
		<span style="color:#75715e">// 新根和老根相关孩子节点关系变更
</span><span style="color:#75715e"></span>		parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> right<span style="color:#f92672">-&gt;</span>left;
		<span style="color:#66d9ef">if</span> (right<span style="color:#f92672">-&gt;</span>left) {
			right<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
		}
		parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> right;
		right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> parent;
		right<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent_parent;
		<span style="color:#75715e">// 建立新根到原根的父节点之间的关系
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (parent_parent) {
			<span style="color:#66d9ef">if</span> (parent <span style="color:#f92672">==</span> parent_parent<span style="color:#f92672">-&gt;</span>left) {
				parent_parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> right;
			}
			<span style="color:#66d9ef">else</span> {
				parent_parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> right;
			}
		}
		<span style="color:#66d9ef">return</span> right;
	}

	<span style="color:#75715e">// 右旋，返回右旋后新的根
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> right_rotate(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> left <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>left;
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent_parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>left)
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
		parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left<span style="color:#f92672">-&gt;</span>right;
		<span style="color:#66d9ef">if</span> (left<span style="color:#f92672">-&gt;</span>right) {
			left<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
		}
		parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> left;
		left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> parent;
		left<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent_parent;
		<span style="color:#66d9ef">if</span> (parent_parent) {
			<span style="color:#66d9ef">if</span> (parent <span style="color:#f92672">==</span> parent_parent<span style="color:#f92672">-&gt;</span>left) {
				parent_parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
			}
			<span style="color:#66d9ef">else</span> {
				parent_parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> left;
			}
		}
		<span style="color:#66d9ef">return</span> left;
	}

	<span style="color:#75715e">// 在二叉搜索树中查询指定数据，返回nullptr，或空数据节点，或包含当前data的节点
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> query(binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current <span style="color:#f92672">=</span> root;
		<span style="color:#66d9ef">while</span> (current<span style="color:#f92672">&amp;&amp;</span>current<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">&amp;&amp;</span>current<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span>data) {
			<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> data) {
				current <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(current<span style="color:#f92672">-&gt;</span>left);
			}
			<span style="color:#66d9ef">else</span> {
				current <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(current<span style="color:#f92672">-&gt;</span>right);
			}
		}
		<span style="color:#66d9ef">return</span> current;
	}

	<span style="color:#75715e">// 返回中序遍历下的节点指针列表
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> inorder(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;&amp;</span> in_order_list) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>times)
			<span style="color:#66d9ef">return</span>;
		inorder(root<span style="color:#f92672">-&gt;</span>left, in_order_list);
		in_order_list.push_back(root);
		inorder(root<span style="color:#f92672">-&gt;</span>right, in_order_list);
	}

	<span style="color:#75715e">// 获取当前根所带子树下的最小值节点，不存在（空树）返回nullptr，存在则返回对应节点
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> tree_minimum(binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current <span style="color:#f92672">=</span> root;
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> memory <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		<span style="color:#66d9ef">while</span> (current <span style="color:#f92672">&amp;&amp;</span> current<span style="color:#f92672">-&gt;</span>times) {
			memory <span style="color:#f92672">=</span> current;
			current <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>left;
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(memory);
	}

	<span style="color:#75715e">/*
</span><span style="color:#75715e">	* return the last data node that is after data in the inorder
</span><span style="color:#75715e">	*/</span>
	<span style="color:#75715e">// 返回中序遍历下data的后继，要求data必须存在于树中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> successor(binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current <span style="color:#f92672">=</span> query(root,data);
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>current <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>current<span style="color:#f92672">-&gt;</span>times)
			<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;data not in tree, can&#39;t search successor&#34;</span>);
		<span style="color:#75715e">// 有右子树，返回右子树中最小值
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">&amp;&amp;</span> current<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>times)
			<span style="color:#66d9ef">return</span> tree_minimum(<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(current<span style="color:#f92672">-&gt;</span>right));
		<span style="color:#75715e">// 否则需要找到父结点中第一个比自己大的
</span><span style="color:#75715e"></span>		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> memory <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">while</span> (memory <span style="color:#f92672">&amp;&amp;</span> memory<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">==</span>current) {
			current <span style="color:#f92672">=</span> memory;
			memory <span style="color:#f92672">=</span> memory<span style="color:#f92672">-&gt;</span>parent;
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(memory);
	}

	<span style="color:#75715e">// 插入后恢复红黑树
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> redblack_tree_insert_fix(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> new_node) {
		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current_node <span style="color:#f92672">=</span> new_node;
		<span style="color:#75715e">// current始终指向一个红节点，因此退出条件为：抵达根节点，或者父节点不红
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED) {
			<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left) { <span style="color:#75715e">// 父节点为左孩子
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right 
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED) {
					<span style="color:#75715e">// 情形一
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (current_node <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right) {
					<span style="color:#75715e">// 情形二
</span><span style="color:#75715e"></span>					current_node <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>left);
				}
				<span style="color:#66d9ef">else</span> {
					<span style="color:#75715e">// 情形三
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#75715e">// 若对根旋转，需要更新根结点的值
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">right_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				};
			}
			<span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 镜像情况，将所有左、左旋，替换为右、右旋，反之亦然
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left 
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (current_node <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left) {
					current_node <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>right);
				}
				<span style="color:#66d9ef">else</span> {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">left_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				}
			}
		}
		<span style="color:#75715e">// 针对回到根的情况，需要保证根是黑色
</span><span style="color:#75715e"></span>		(<span style="color:#f92672">*</span>root)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
	}

	<span style="color:#75715e">// 向红黑树插入数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> redblack_tree_insert(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		<span style="color:#75715e">// 空树直接插入
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!*</span>root) {
			<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">nullptr</span>, data, NODE_COLOR<span style="color:#f92672">::</span>BLACK);
			<span style="color:#66d9ef">return</span>;
		}
		<span style="color:#75715e">// 查询是否已经存在
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> query_node <span style="color:#f92672">=</span> to_rbnode(query(<span style="color:#f92672">*</span>root, data));
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>query_node<span style="color:#f92672">-&gt;</span>is_nil) {
			query_node<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">++</span>;
			<span style="color:#66d9ef">return</span>;
		}
		<span style="color:#75715e">// 不存在的情况下，query返回的是恰好可用于插入的空数据节点，提升为内部节点
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> insert_node <span style="color:#f92672">=</span> query_node;
		insert_node<span style="color:#f92672">-&gt;</span>to_inner(data);
		<span style="color:#75715e">// 恢复红黑树性质
</span><span style="color:#75715e"></span>		redblack_tree_insert_fix(root, insert_node);
	}

	<span style="color:#75715e">// 删除红黑树节点后的性质恢复
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> redblack_tree_delete_fix(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current_node) {
		<span style="color:#75715e">// 退出条件为抵达根节点，或当前节点不为黑色
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (current_node <span style="color:#f92672">!=</span> <span style="color:#f92672">*</span>root <span style="color:#f92672">&amp;&amp;</span> current_node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
			<span style="color:#66d9ef">if</span> (current_node <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left) { <span style="color:#75715e">// 当前节点是左孩子
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					<span style="color:#75715e">// 情形一
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">left_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>is_nil
					<span style="color:#f92672">||</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK)) {
					<span style="color:#75715e">// 情形二
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					<span style="color:#75715e">// 情形三
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right));
					<span style="color:#66d9ef">else</span>
						right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right);
				}
				<span style="color:#66d9ef">else</span> {
					<span style="color:#75715e">// 情形四
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color 
						<span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">left_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">right_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>is_nil
					<span style="color:#f92672">||</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK)) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left));
					<span style="color:#66d9ef">else</span>
						left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left);
				}
				<span style="color:#66d9ef">else</span> {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color 
						<span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">right_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
					current_node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>root;
				}
			}
		}
		<span style="color:#75715e">// 保持根为黑，或者对当前红节点添加黑色（完成对缺失的黑色的补充）
</span><span style="color:#75715e"></span>		current_node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
	}

	<span style="color:#75715e">// 从红黑树中删除指定数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">bool</span> redblack_tree_delete(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node<span style="color:#f92672">=</span>to_rbnode(query(<span style="color:#f92672">*</span>root, data));
		<span style="color:#75715e">// 数据不存在
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_nil)
			<span style="color:#66d9ef">return</span> false;
		<span style="color:#75715e">// 数据有多份，暂时不用删除节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
			node<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">--</span>;
			<span style="color:#66d9ef">return</span> true;
		}
		<span style="color:#75715e">// 寻找删除节点
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> remove_node<span style="color:#f92672">=</span><span style="color:#66d9ef">nullptr</span>;
		<span style="color:#66d9ef">if</span> (to_rbnode(node<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>is_nil 
			<span style="color:#f92672">||</span> to_rbnode(node<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>is_nil) {
			remove_node <span style="color:#f92672">=</span> node;
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// 如果节点有双孩子，则不会被直接删除，而会被其后继节点数据替代，后继节点会被删除
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// 后继节点可以被删除的原因是，在当前节点双孩子的前提下，后继节点至多有一个右孩子
</span><span style="color:#75715e"></span>			remove_node <span style="color:#f92672">=</span> to_rbnode(successor(<span style="color:#f92672">*</span>root, node<span style="color:#f92672">-&gt;</span>data));
		}
		<span style="color:#75715e">// 寻找保留节点（后继节点的左孩子或右孩子）
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> save_node <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		<span style="color:#66d9ef">if</span> (to_rbnode(remove_node<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>is_nil) {
			save_node <span style="color:#f92672">=</span> to_rbnode(remove_node<span style="color:#f92672">-&gt;</span>right);
			remove_node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		}
		<span style="color:#66d9ef">else</span> {
			save_node <span style="color:#f92672">=</span> to_rbnode(remove_node<span style="color:#f92672">-&gt;</span>left);
			remove_node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		}
		<span style="color:#75715e">// 由后继节点替代时，需要复制数据
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (remove_node <span style="color:#f92672">!=</span> node) {
			node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> remove_node<span style="color:#f92672">-&gt;</span>data;
			node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">=</span> remove_node<span style="color:#f92672">-&gt;</span>times;
		}
		<span style="color:#75715e">// 和父节点的关系重设
</span><span style="color:#75715e"></span>		save_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> remove_node<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">if</span> (remove_node<span style="color:#f92672">-&gt;</span>parent) {
			<span style="color:#75715e">// remove_node is NOT root
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (remove_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> remove_node) {
				remove_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> save_node;
			}
			<span style="color:#66d9ef">else</span> {
				remove_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> save_node;
			}
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// 删除根节点时更新根
</span><span style="color:#75715e"></span>			<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> save_node;
		}
		<span style="color:#75715e">// 删除了一个黑节点，部分路径黑高度减一，需要恢复性质
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(remove_node<span style="color:#f92672">-&gt;</span>color<span style="color:#f92672">==</span>NODE_COLOR<span style="color:#f92672">::</span>BLACK)
			redblack_tree_delete_fix(root, save_node);
		<span style="color:#75715e">// 移除待删除节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">delete</span> remove_node;
		<span style="color:#66d9ef">return</span> true;
	}

	<span style="color:#75715e">// 工具函数，打印内部节点值、颜色、父节点值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> rbtree_print(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>root<span style="color:#f92672">==</span><span style="color:#66d9ef">nullptr</span>) {
			std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;rbtree empty&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">return</span>;
		}
		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;====rbtree start====&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
		std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> order_list;
		inorder<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">*</span>root, order_list);
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> t : order_list) {
			std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> enum_trans(to_rbnode(t)<span style="color:#f92672">-&gt;</span>color) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  &lt;&lt;  &#34;</span>;
			<span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>parent)
				std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">else</span>
				std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;root&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
		}
		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;====rbtree  end ====&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	}
}
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> rbtree_delete_test(lyc_algorithm<span style="color:#f92672">::</span>redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span>root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span>data) {
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	<span style="color:#66d9ef">if</span> (redblack_tree_delete<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(root, data)) {
		rbtree_print(root);
	}
	<span style="color:#66d9ef">else</span> {
		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; not exist in rbtree&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	}
}

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> rbtree_insert_test(lyc_algorithm<span style="color:#f92672">::</span>redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	redblack_tree_insert<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(root, data);
	rbtree_print(root);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======tree_examples======&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	redblack_tree_node<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">10</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">11</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">1</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">5</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">0</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">17</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">14</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">13</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">12</span>);

	<span style="color:#75715e">//std::cout &lt;&lt; &#34;====rbtree_delete====&#34; &lt;&lt; std::endl;
</span><span style="color:#75715e"></span>	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">233</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">10</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">11</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">1</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">5</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">0</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">17</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">14</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">13</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">12</span>);

	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">3</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">2</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);

	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">3</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);


	redblack_tree_node<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;*</span> strRoot <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>strRoot, std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;233&#34;</span>));
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>strRoot, std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;666&#34;</span>));
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>strRoot, std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;789&#34;</span>));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="跳跃表">跳跃表</h1>
<h1 id="b树">B树</h1>
<h1 id="树堆treap">树堆（Treap）</h1>
<h1 id="二项堆">二项堆</h1>
<h1 id="斐波那契堆">斐波那契堆</h1>
<h1 id="在写作本章节时记录的博客问题">在写作本章节时记录的博客问题</h1>
<ol>
<li>在使用mathjax的\$\$对儿中，如果直接写[x]，则会显示出来一个<input checked="" disabled="" type="checkbox"> ，如果想要正常显示[x]，需要写为\\[x\\]。
<ul>
<li>markdown的转义。。。有的时候真的令人无语。</li>
</ul>
</li>
</ol>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://www.lyclife.com/tags/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/">算法系列</a>

  <a class="tag tag--primary tag--small" href="https://www.lyclife.com/tags/%E6%96%BD%E5%B7%A5%E4%B8%AD/">施工中</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E5%85%AB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-tooltip="算法导论其八：动态规划">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E9%A5%A5%E8%8D%92linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" data-tooltip="饥荒Linux服务器搭建教程">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 李奕成. All Rights Reserved 
  </span>
  <a href="https://beian.miit.gov.cn/#/Integrated/index" target="blank">吉ICP备2021004867</a>
  
  <div>
    <img src="https://www.lyclife.com/images/beian.png">
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502045148" target="blank">京公网安备11010502045148</a>
  </div>
  
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E5%85%AB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-tooltip="算法导论其八：动态规划">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E9%A5%A5%E8%8D%92linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" data-tooltip="饥荒Linux服务器搭建教程">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://www.lyclife.com/images/author.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">李奕成</h4>
    
      <div id="about-card-bio">每天都是最好的一天</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        京投 软件研发
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        北京·朝阳
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://www.lyclife.com/images/background/bridge_linjiangmen.jpg');"></div>
    
  


    
<script src="https://www.lyclife.com/scripts/jquery360/jquery.min.js"></script>

<script src="https://www.lyclife.com/scripts/highlight.min.js"></script>


<script src="https://www.lyclife.com/scripts/fancybox-2.1.7/jquery.fancybox.min.js"></script>


<script src="https://www.lyclife.com/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      CommonHTML: { linebreaks: { automatic: true } },
      tex2jax: { inlineMath: [ ['$', '$'], ['\\(','\\)'] ], displayMath: [ ['$$','$$'], ['\\[', '\\]'] ], processEscapes: false },
      messageStyle: 'none'
    });
  </script>



    
  </body>
</html>

