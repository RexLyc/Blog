---
title: "算法导论其五：哈希表"
date: 2021-08-16T10:10:21+08:00
categories:
- 计算机科学与技术
- 算法
tags:
- 算法系列
- 施工中
thumbnailImagePosition: left
thumbnailImage: images/thumbnail/algorithm.jpg
math: true
---
哈希表的使用概率实在是太高太高啦，毕竟常数级的期望时间复杂度是真的诱惑。大部分语言都提供良好的哈希表数据结构。底层的原理进来了解一下呀。
<!--more-->
# 基本概念
1. 散列表（hash table）：哈希表的真正学名。提供根据关键字进行访问数据能力的一类数据结构。
2. 散列函数：即哈希函数，用于将关键字转换为散列地址，进行数据访问。
3. 关键字（key）：不同元素之间用来区分的数据字段。
4. 槽（slot）：散列表中的一个存储单元，其对应的地址叫做散列地址。
5. 装载因子（load factor）：一个能存放n个元素，具有m个槽位的散列表，其装载因子$\alpha = n / m$，$\alpha$可以小于、等于、大于1。
# 直接寻址表
&emsp;&emsp; 如果关键字的域$\mathrm{U}=\\{0,1,2....,m-1\\}$比较小，则可以让每个关键字都直接对应表中的一个下标值。这种方法实际上不需要经过散列函数，基本就是原始数组。
# 散列表
- 直接寻址法有相当明显的问题，如果域U很大，我们是不能把它全存在内存里的。而且如果数据分布并不均匀，大部分空间都将被浪费。
- 散列表做出的改进就是，利用散列函数h，将关键字域U映射到散列表的n个散列地址上，即$h:U\to \\{0,1,...,n-1\\}$。经过散列函数的映射，散列表实际上只需要管理n个大小的表空间。
- **新的问题**：不同的关键字可能被映射到同一个槽（碰撞）。需要想办法避免。
# 选择更好的散列函数
- 目标：针对输入的关键字域，提供尽量满足简单一致散列（任何元素散列到任何槽中的概率均相同，且和其他元素已被散列情况独立无关）假设的映射。
- 首先：将关键字解释为自然数。多数散列函数都需要输入的关键字域为自然数集，如果输入不是，如字符串、浮点数。需要有办法先转换为自然数。
- 除法散列法：$h(k)=k &ensp; mod &ensp; n$。n的选取是一门玄学，一般可选一个质数（碰撞发生概率相对更小一些）。
- 乘法散列法：$h(k)=\lfloor m(kA &ensp; mod &ensp; 1) \rfloor$。关键字k乘一个常数A ( 0 < A < 1 )，并抽出小数部分。最后用m乘，并取结果的底。这里说的方法是在实数域上进行运算的。
<!-- TODO 插一张乘法散列法的图，并给出一个具体实用的乘法散列法 -->
    - 实际上也有一些关于m、A等的推荐。例如Knuth建议选择A接近黄金分割比。
<!-- TODO -->
- 全域散列法：
# 散列后解决碰撞
- 链接法：每一个槽内保存一个链表，再存储具体数据元素。
    - 有严格证明，在槽数和元素数成正比的情况下，则能保证操作时间满足平均$\mathrm{O}(1)$。
<!-- TODO -->
- 开放散列法：
<!-- TODO -->
- 完全散列法：
# 数据结构还是算法
虽然看起来散列表是一种数据结构，但是其实取散列的思想是一种非常常见的算法套路。比如当我们需要判断两个元素的内容是否完全相同时，就可以先判断其散列值是否相同，相同再在内容中逐字段深度比较，散列值不同则一定不相同。