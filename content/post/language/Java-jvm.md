---
title: "Java系列：JVM篇"
date: 2024-03-18T10:11:23+08:00
categories:
- 计算机科学与技术
- 编程语言
tags:
- Java系列
thumbnailImagePosition: left
thumbnailImage: /images/thumbnail/java.jpg
draft: true
---
本篇记录Java的JVM的一些设计、实现细节，对程序开发和面试有一定帮助。
<!--more-->
## 内存模型
### 引用

### 垃圾回收
JVM历史上有多个垃圾回收算法。其中广泛使用的是，Parallel GC和CMS，G1，ZGC。从Java标准来看，Java8中主要使用的是PGC和CMS，Java21之后应当使用ZGC（在hotspotVM中）。

有一些术语值得学习：[记忆集和卡表](https://developer.aliyun.com/article/1097566)

这些方法的主要算法，都是基于标记-清理-复制算法。具体可以分为三个阶段：
- 标记阶段，即从GC Roots集合开始，标记活跃对象
- 转移阶段，即把活跃对象复制到新的内存地址上
- 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上

在具体实现过程中，都会加入并发的手段，以减少STW时间。在G1算法中，标记阶段也会被分为三个阶段
1. 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。
1. 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。
1. 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。

但G1的清理和复制阶段则都需要STW。而且这个阶段的耗时会随着对象的增多而线性增长。

可见停顿主要来自于清理和复制，而G1无法在这一步做更多的并发优化的原因，是无法确切定位对象位置。即并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。

> 在ZGC之前，垃圾回收所需要的信息，都存储在对象头内。

> 只有从堆中读取引用会发生这个问题，因为堆内存被GC改变了。

ZGC通过着色指针和读屏障解决了这一问题。首先需要理解ZGC中使用的对象指针。

| 0~41位 | 42~45位 | 46~53位 |
| --- | --- | --- |
| 保存对象信息（地址），寻址空间4TB | 三色标记（M0、M1、Remapped）以及是否需要Finalize| 保留18位 |

由于ZGC对指针进行了重新的定义，因此还需要依赖于虚拟内存映射机制。多个ZGC的指针，实际可能指向的是同一个物理地址。即同一块物理内存，可能同时映射为M0（Marked 0）、M1、Remapped。但是任意时刻，只有一个视图是有效的。

ZGC也提供了多种触发GC的机制：分配时、分配速率、固定间隔、主动、外部触发、元数据区分配。

> ZGC并不是银弹，ZGC是单代垃圾回收器。从本质上和G1等方法有区别。因此在具体场景下还需要具体分析。


### 本地内存


## 参考
1. [新一代垃圾回收器ZGC的探索与实践](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)
2. [深入解析ZGC垃圾回收器](https://www.cnblogs.com/booksea/p/17665685.html)