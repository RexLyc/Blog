<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.87.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="李奕成">
<meta name="keywords" content="">
<meta name="description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">


<meta property="og:description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">
<meta property="og:type" content="article">
<meta property="og:title" content="算法导论其七：树">
<meta name="twitter:title" content="算法导论其七：树">
<meta property="og:url" content="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E4%B8%83%E6%A0%91/">
<meta property="twitter:url" content="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E4%B8%83%E6%A0%91/">
<meta property="og:site_name" content="奕成的个人空间">
<meta property="og:description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">
<meta name="twitter:description" content="树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2021-08-27T10:30:52">
  
  
    <meta property="article:modified_time" content="2021-08-27T10:30:52">
  
  
  
    
      <meta property="article:section" content="计算机科学与技术">
    
      <meta property="article:section" content="算法">
    
  
  
    
      <meta property="article:tag" content="算法系列">
    
      <meta property="article:tag" content="施工中">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://www.lyclife.com/images/thumbnail/algorithm.jpg">
  <meta property="twitter:image" content="https://www.lyclife.com/images/thumbnail/algorithm.jpg">





  <meta property="og:image" content="https://www.lyclife.com/images/author.jpg">
  <meta property="twitter:image" content="https://www.lyclife.com/images/author.jpg">


    
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\[\[", "\]\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };
</script>
<script src="https://www.lyclife.com/scripts/polyfill.min.js"></script>
<script
  id="MathJax-script"
  async
  src="https://www.lyclife.com/scripts/MathJax-3.2.0/es5/tex-mml-chtml.js"
></script>

    <title>算法导论其七：树</title>

    <link rel="icon" href="https://www.lyclife.com/images/favicon.png">
    

    

    <link rel="canonical" href="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E4%B8%83%E6%A0%91/">

    
    <link href="https://www.lyclife.com/scripts/Font-Awesome-4.7.0/css/font-awesome.css" rel="stylesheet">
    
    
    <link href="https://www.lyclife.com/scripts/fancybox-2.1.7/source/jquery.fancybox.css" rel="stylesheet">
    <link href="https://www.lyclife.com/scripts/fancybox-2.1.7/source/helpers/jquery.fancybox-thumbs.css" rel="stylesheet">
    
    
    <link rel="stylesheet" href="https://www.lyclife.com/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://www.lyclife.com/">奕成的个人空间</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://www.lyclife.com/#about">
    
    
    
      
        <img class="header-picture" src="https://www.lyclife.com/images/author.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://www.lyclife.com/#about">
          <img class="sidebar-profile-picture" src="https://www.lyclife.com/images/author.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">李奕成</h4>
        
          <h5 class="sidebar-profile-bio">每天都是最好的一天</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/RexLyc" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.lyclife.com/images/wechat.jpg">
    
      <i class="sidebar-button-icon fa fa-lg fa-wechat"></i>
      
      <span class="sidebar-button-desc">微信</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      算法导论其七：树
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-08-27T10:30:52&#43;08:00">
        
  八月 27, 2021

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://www.lyclife.com/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%8e%e6%8a%80%e6%9c%af">计算机科学与技术</a>, 
    
      <a class="category-link" href="https://www.lyclife.com/categories/%e7%ae%97%e6%b3%95">算法</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>树是一类特殊的图，但和图不一样的是，树作为数据结构的应用十分广泛。还有各种各样的变种用于加速一些特定领域的算法。性能是相当的妙啦~</p>
<h1 id="有根树">有根树</h1>
<ul>
<li>实际上只是一种数据结构。用链接的方式，构造出一个树状的数据结构。</li>
<li>术语：
<ul>
<li>根：有根树的最上层节点，在树中，只有这个节点是没有双亲结点的</li>
<li>子树：树的定义是递归的，每一个节点和它的子孙节点都构成整个树的一棵子树</li>
<li>度：每个节点的<strong>子节点的个数</strong>称为该节点的度，树的度取所有节点的度中最大的</li>
<li>深度：从根节点向下逐层累加。</li>
<li>高度：从最底层叶子节点自底向上累加。
<ul>
<li>对于每个节点来说，深度和高度不一定相等，但一棵树的深度和高度相等。</li>
</ul>
</li>
<li>域：$p,left,right$，分别用于指示二叉树中的双亲、左孩子、右孩子，例如：
<ul>
<li>$p[x]= NIL$，则代表x是根。$p[x]\gets y$，则表示将y设置为x的双亲节点（parent缩写为p）</li>
<li>$left[x]= NIL$，代表x没有左孩子。$left[x]\gets y$，表示将y设置为x的左孩子</li>
</ul>
</li>
<li>扩展的域：$right-sibling$，指示二叉树中最近邻的右侧的兄弟（位于树的同一层的都是兄弟节点）</li>
<li>一些常用的树：
<ul>
<li>二叉树：每个节点的度$\le 2$。</li>
<li>二叉查找（二叉搜索树）：对任何节点$t$，若左子树存在，则左子树节点值永远不大于$t$的值。若右子树存在，则右子树的值永远不小于$t$的值。</li>
<li>平衡搜索树（AVL树）：二叉搜索树的一种，并且满足任何左子树和右子树高度之差不会大于1。</li>
<li>满二叉树：除了叶子节点，所有节点度为2。</li>
<li>完全二叉树：最后一层叶子节点均在左侧的满二叉树。</li>
<li>完美二叉树：每一层均被填满的二叉树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 一个典型的指针实现的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">tree_node</span> {
    tree_node <span style="color:#f92672">*</span>left, <span style="color:#f92672">*</span>right;
    tree_node <span style="color:#f92672">*</span>parent;
    T val;
    
    tree_node(T val)
        <span style="color:#f92672">:</span> left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>), parent(<span style="color:#66d9ef">nullptr</span>),val(val) {}

    tree_node(T val, tree_node <span style="color:#f92672">*</span>left, tree_node <span style="color:#f92672">*</span>right, tree_node <span style="color:#f92672">*</span>parent)
        <span style="color:#f92672">:</span> val(val), left(left), right(right), parent(parent) {}
};
</code></pre></div><h1 id="二叉查找树二叉搜索树">二叉查找树（二叉搜索树）</h1>
<ul>
<li>普通的有根树有什么用吗？没有。节点之间只有满足一些性质的时候，树才会显现出威力。</li>
<li>二叉查找树是查找树的一种，定义已在上一小节给出。</li>
<li>提供的核心操作：插入、删除、查询。一个良好实现的二叉查找树均能实现$O(logn)$的复杂度，$n$为树的高度。</li>
<li>其他基础操作：子树最小元素（Tree-Minimum）、子树最大元素（Tree-Maximum）、节点中序遍历下的前驱（Tree-Predecessor）、节点中序遍历下的后继（Tree-Successor）</li>
<li>常见的实用二叉搜索树：
<ol>
<li>AVL树：得名于其发明者的名字（ Adelson-Velskii 以及 Landis）。AVL树是最先发明的严格自平衡二叉查找树，其任何节点的左右子树高度差绝对值小于1。</li>
<li>红黑树：下面就讲啦。</li>
</ol>
</li>
</ul>
<h1 id="红黑树">红黑树</h1>
<ul>
<li>
<p>一种非常使用的二叉查找树的实现。保证最坏的情况下依然满足插入、删除、查询的操作时间为$O(logn)$。</p>
</li>
<li>
<p>红黑树保证没有一条路径的长度会比其他路径长出两倍，因而是接近平衡的。红黑树这种宽松的平衡条件，比AVL树的绝对平衡，在插入和删除时有性能优势，但在查询时是处于劣势的。</p>
</li>
<li>
<p>充要条件：</p>
<ol>
<li>每个节点或者是红色，或者是黑色</li>
<li>根节点是黑色的</li>
<li>每个叶子节点（NIL）是黑色的，叶子节点不存储数据，存储节点的数据也被称为内部节点</li>
<li>如果一个节点是红色的，则它的孩子节点都是黑色的</li>
<li>对于每一个节点，从该节点到其子孙叶子节点的所有路径上包含相同数目的黑节点</li>
</ol>
</li>
<li>
<p>核心操作：旋转和重新着色。目标是在树发生结构变化时，令树继续保持充要条件。</p>
<ol>
<li>旋转：旋转操作实现时，只需要进行指针变换，左右旋转都可以在$O(1)$内完成。
</br><center>
<img src="https://www.lyclife.com/images/algoSeries/TreeRotate.svg" alt="树的旋转操作"></li>
</ol>
  </center>
<ol start="2">
<li>重新着色：每一次新节点插入时，以基础的二叉查找树的插入方式，将新节点插入书中，并固定的设置新节点的颜色为红色。这会导致新树不满足原有的红黑树在着色方面的要求。同理，删除节点时也会破坏原有性质。此时将会根据情况重新对部分节点进行重新上色（红色变黑色，黑色变红色）。</li>
</ol>
</li>
<li>
<p>插入：在二叉查找树的插入操作的基础上，添加重新着色和旋转操作。向树$T$插入$z$的步骤如下：</p>
<ol>
<li>自根向下查找大小适合插入$z$的位置，并插入
<ul>
<li>空树则$z$直接为根</li>
</ul>
</li>
<li>设置$z$为红色</li>
<li>插入的重着色和旋转：
<ol>
<li>循环2或3直到$color[p[z]]=BLACK$</li>
<li>父节点为左孩子
<ol>
<li>叔父节点红色：情形一，$z$上移</li>
<li>叔父节点黑色，$z$为右孩子：情形二，变更$z$</li>
<li>情形三</li>
</ol>
</li>
<li>父节点为右孩子
<ul>
<li>处理方式为镜像情况</li>
</ul>
</li>
<li>将根赋值为黑色</li>
</ol>
</li>
</ol>
<p></br><center>
<img src="https://www.lyclife.com/images/algoSeries/RB-Tree-INSERT.svg" alt="红黑树的插入操作">
</br>三种插入情形</p>
  </center>
</li>
<li>
<p>删除：删除操作也是在二叉查找树的删除操作的基础上，进行修改得来的。重新着色和旋转情况与插入相比，情况稍微复杂。从树$T$删除$z$的步骤如下：</p>
<ol>
<li>寻找待删除节点$y$
<ul>
<li>若$left[z]=nil[T]$或$right[z]=nil[T]$，则$y\gets z$</li>
<li>否则$y\gets Tree-Successor(z)$，即实际删除中序遍历下的后继节点（后续会将当前$z$节点的值替换为后继）</li>
</ul>
</li>
<li>计算保留节点$x$，$x$将会代替$y$的位置，并令$p[x]\gets p[y]$
<ul>
<li>若$left[y]\ne nil[T]$，则$x\gets left[y]$</li>
<li>否则$x\gets right[y]$（$x$可能为$nil[T]$）</li>
</ul>
</li>
<li>调整$p[y]$的$left$，$right$域
<ul>
<li>若$y$为根，令$x$为根</li>
<li>若$y$不为根，且为左孩子，则$x$也为左孩子，反之亦然。</li>
</ul>
</li>
<li>若$y\ne z$（意味着取了后继），$key[z]\gets key[y]$，即将卫星数据拷贝过去。</li>
<li>若$color[y]=BLACK$，进行删除的重着色和旋转（对保留下来的$x$进行）
<ol>
<li>若$x\ne root[T]$且$color[x]=BLACK$，循环处理2或3</li>
<li>若$x$为左孩子
<ol>
<li>若$x$的兄弟$w$为红色，情形一</li>
<li>若$x$的兄弟$w$为黑色，且$w$的左右孩子均为黑色，情形2</li>
<li>若$x$的兄弟$w$为黑色，且$w$的右孩子为黑色，情形3</li>
<li>情形4（C取A原色）</li>
</ol>
</li>
<li>若$x$为右孩子，操作均为镜像</li>
<li>$color[x]\gets BLACK$</li>
</ol>
</li>
</ol>
<p></br><center>
<img src="https://www.lyclife.com/images/algoSeries/RB-Tree-Delete.svg" alt="红黑树的删除操作">
</br>四种删除情形(绿色代表该节点颜色无所谓)
</br>注：情形4中C取A色，D色不变</p>
  </center>
</li>
<li>
<p>关于插入和删除の一点理解：重新着色和旋转操作都是为了恢复红黑树的性质，对于每种情况，要看懂到能够理解违反了哪项性质，操作之后是否恢复，或者是否让子树部分恢复，并递归向上。</p>
<ul>
<li>插入的问题是两个红色相邻</li>
<li>删除的主要问题是，<strong>包含删除节点的任意路径，黑高度降低</strong>。（另外还可能有其他性质被打破）
<ul>
<li>这里主要需要思考清楚的是情形一和二，这两者不会重复循环出现：若是从情形一到情形二，则将会很快退出循环；若是从情形二到情形一，则至多为二到一再到二，并退出</li>
<li>一旦进入情形三、四，将会很快退出</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 这玩意儿能写好久
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> lyc_algorithm {

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binary_tree_node</span> {
		binary_tree_node<span style="color:#f92672">*</span> parent;
		binary_tree_node<span style="color:#f92672">*</span> left;
		binary_tree_node<span style="color:#f92672">*</span> right;
		T data;
		<span style="color:#75715e">// 数据存储次数
</span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>size_t times;
		binary_tree_node(binary_tree_node<span style="color:#f92672">*</span> parent
			, binary_tree_node<span style="color:#f92672">*</span> left, binary_tree_node<span style="color:#f92672">*</span> right, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data)
			<span style="color:#f92672">:</span>parent(parent), left(left), right(right), data(data),times(<span style="color:#ae81ff">1</span>) {}
		binary_tree_node()
			<span style="color:#f92672">:</span>parent(<span style="color:#66d9ef">nullptr</span>), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>),times(<span style="color:#ae81ff">0</span>) {}
		binary_tree_node(binary_tree_node<span style="color:#f92672">*</span> parent)
			<span style="color:#f92672">:</span>parent(parent), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>), times(<span style="color:#ae81ff">0</span>) {}
	};



	<span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NODE_COLOR</span> {
		RED, BLACK
	};

	std<span style="color:#f92672">::</span>string enum_trans(<span style="color:#66d9ef">const</span> NODE_COLOR<span style="color:#f92672">&amp;</span> e) {
		<span style="color:#66d9ef">switch</span> (e) {
			<span style="color:#66d9ef">case</span> NODE_COLOR<span style="color:#f92672">::</span>RED:
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;RED&#34;</span>;
			<span style="color:#66d9ef">case</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK:
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;BLACK&#34;</span>;
			<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;??&#34;</span>;
		}
	}

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binary_search_tree_node</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
		binary_search_tree_node(binary_search_tree_node<span style="color:#f92672">*</span> parent
			, binary_search_tree_node<span style="color:#f92672">*</span> left, binary_search_tree_node<span style="color:#f92672">*</span> right, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data)
			<span style="color:#f92672">:</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent, left, right, data) {}
		binary_search_tree_node()
			<span style="color:#f92672">:</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>() {}
		binary_search_tree_node(binary_search_tree_node<span style="color:#f92672">*</span> parent)
			<span style="color:#f92672">:</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent) {}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">redblack_tree_node</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
		<span style="color:#75715e">// 创建一个内部节点
</span><span style="color:#75715e"></span>		redblack_tree_node(redblack_tree_node<span style="color:#f92672">*</span> parent
			, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data,  NODE_COLOR color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED)
			<span style="color:#f92672">:</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent
				, <span style="color:#66d9ef">new</span> redblack_tree_node(<span style="color:#66d9ef">this</span>), <span style="color:#66d9ef">new</span> redblack_tree_node(<span style="color:#66d9ef">this</span>), data)
			, color(color) ,is_nil(false){}

		<span style="color:#75715e">// 创建一个无数据的叶子节点
</span><span style="color:#75715e"></span>		redblack_tree_node(redblack_tree_node<span style="color:#f92672">*</span> parent)
			<span style="color:#f92672">:</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(parent), color(NODE_COLOR<span style="color:#f92672">::</span>BLACK) ,is_nil(true) {}

		NODE_COLOR color;
		<span style="color:#66d9ef">bool</span> is_nil;

		<span style="color:#75715e">// 废弃：待删除节点应当直接被删除，而不是转为叶子节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">to_nil</span>() {
			<span style="color:#66d9ef">if</span> (is_nil) {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;this node is already a nil&#34;</span>);
			}
			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left)<span style="color:#f92672">-&gt;</span>is_nil)
				<span style="color:#f92672">||</span> <span style="color:#f92672">!</span>(to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right)<span style="color:#f92672">-&gt;</span>is_nil)) {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;to_nil should only apply to the node which has two nil childs&#34;</span>);
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left;
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right;
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>times <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
				is_nil <span style="color:#f92672">=</span> true;
				color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
			}
		}

		<span style="color:#75715e">// 将叶子节点转为内部节点，并自动创建新的叶子节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">to_inner</span>(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
			<span style="color:#66d9ef">if</span> (is_nil) {
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>data <span style="color:#f92672">=</span> data;
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>times <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
				is_nil <span style="color:#f92672">=</span> false;
				<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span>);
				binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span>);
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;this node is already a inner node&#34;</span>);
			}
		}

		<span style="color:#75715e">// 析构时删除存在的叶子孩子节点
</span><span style="color:#75715e"></span>		<span style="color:#f92672">~</span>redblack_tree_node() {
			<span style="color:#66d9ef">if</span> (binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left <span style="color:#f92672">&amp;&amp;</span> to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left)<span style="color:#f92672">-&gt;</span>is_nil) {
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>left;
			}
			<span style="color:#66d9ef">if</span> (binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right <span style="color:#f92672">&amp;&amp;</span> to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right)<span style="color:#f92672">-&gt;</span>is_nil) {
				<span style="color:#66d9ef">delete</span> binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>right;
			}
		}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">constexpr</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> to_rbnode(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node) {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(node);
	}

	<span style="color:#75715e">// 左旋：返回左旋后新的根
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> left_rotate(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> right <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>right;
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent_parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>right) <span style="color:#75715e">// 不存在右孩子，结构不支持左旋
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
		<span style="color:#75715e">// 新根和老根相关孩子节点关系变更
</span><span style="color:#75715e"></span>		parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> right<span style="color:#f92672">-&gt;</span>left;
		<span style="color:#66d9ef">if</span> (right<span style="color:#f92672">-&gt;</span>left) {
			right<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
		}
		parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> right;
		right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> parent;
		right<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent_parent;
		<span style="color:#75715e">// 建立新根到原根的父节点之间的关系
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (parent_parent) {
			<span style="color:#66d9ef">if</span> (parent <span style="color:#f92672">==</span> parent_parent<span style="color:#f92672">-&gt;</span>left) {
				parent_parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> right;
			}
			<span style="color:#66d9ef">else</span> {
				parent_parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> right;
			}
		}
		<span style="color:#66d9ef">return</span> right;
	}

	<span style="color:#75715e">// 右旋，返回右旋后新的根
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> right_rotate(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> left <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>left;
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent_parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>left)
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
		parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left<span style="color:#f92672">-&gt;</span>right;
		<span style="color:#66d9ef">if</span> (left<span style="color:#f92672">-&gt;</span>right) {
			left<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent;
		}
		parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> left;
		left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> parent;
		left<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> parent_parent;
		<span style="color:#66d9ef">if</span> (parent_parent) {
			<span style="color:#66d9ef">if</span> (parent <span style="color:#f92672">==</span> parent_parent<span style="color:#f92672">-&gt;</span>left) {
				parent_parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
			}
			<span style="color:#66d9ef">else</span> {
				parent_parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> left;
			}
		}
		<span style="color:#66d9ef">return</span> left;
	}

	<span style="color:#75715e">// 在二叉搜索树中查询指定数据，返回nullptr，或空数据节点，或包含当前data的节点
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> query(binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current <span style="color:#f92672">=</span> root;
		<span style="color:#66d9ef">while</span> (current<span style="color:#f92672">&amp;&amp;</span>current<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">&amp;&amp;</span>current<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span>data) {
			<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> data) {
				current <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(current<span style="color:#f92672">-&gt;</span>left);
			}
			<span style="color:#66d9ef">else</span> {
				current <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(current<span style="color:#f92672">-&gt;</span>right);
			}
		}
		<span style="color:#66d9ef">return</span> current;
	}

	<span style="color:#75715e">// 返回中序遍历下的节点指针列表
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> inorder(binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;&amp;</span> in_order_list) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>times)
			<span style="color:#66d9ef">return</span>;
		inorder(root<span style="color:#f92672">-&gt;</span>left, in_order_list);
		in_order_list.push_back(root);
		inorder(root<span style="color:#f92672">-&gt;</span>right, in_order_list);
	}

	<span style="color:#75715e">// 获取当前根所带子树下的最小值节点，不存在（空树）返回nullptr，存在则返回对应节点
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> tree_minimum(binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current <span style="color:#f92672">=</span> root;
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> memory <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		<span style="color:#66d9ef">while</span> (current <span style="color:#f92672">&amp;&amp;</span> current<span style="color:#f92672">-&gt;</span>times) {
			memory <span style="color:#f92672">=</span> current;
			current <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>left;
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(memory);
	}

	<span style="color:#75715e">/*
</span><span style="color:#75715e">	* return the last data node that is after data in the inorder
</span><span style="color:#75715e">	*/</span>
	<span style="color:#75715e">// 返回中序遍历下data的后继，要求data必须存在于树中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> successor(binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current <span style="color:#f92672">=</span> query(root,data);
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>current <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>current<span style="color:#f92672">-&gt;</span>times)
			<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;data not in tree, can&#39;t search successor&#34;</span>);
		<span style="color:#75715e">// 有右子树，返回右子树中最小值
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">&amp;&amp;</span> current<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>times)
			<span style="color:#66d9ef">return</span> tree_minimum(<span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(current<span style="color:#f92672">-&gt;</span>right));
		<span style="color:#75715e">// 否则需要找到父结点中第一个比自己大的
</span><span style="color:#75715e"></span>		binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> memory <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">while</span> (memory <span style="color:#f92672">&amp;&amp;</span> memory<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">==</span>current) {
			current <span style="color:#f92672">=</span> memory;
			memory <span style="color:#f92672">=</span> memory<span style="color:#f92672">-&gt;</span>parent;
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>binary_search_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span>(memory);
	}

	<span style="color:#75715e">// 插入后恢复红黑树
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> redblack_tree_insert_fix(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> new_node) {
		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current_node <span style="color:#f92672">=</span> new_node;
		<span style="color:#75715e">// current始终指向一个红节点，因此退出条件为：抵达根节点，或者父节点不红
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED) {
			<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left) { <span style="color:#75715e">// 父节点为左孩子
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right 
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED) {
					<span style="color:#75715e">// 情形一
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (current_node <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right) {
					<span style="color:#75715e">// 情形二
</span><span style="color:#75715e"></span>					current_node <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>left);
				}
				<span style="color:#66d9ef">else</span> {
					<span style="color:#75715e">// 情形三
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#75715e">// 若对根旋转，需要更新根结点的值
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">right_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				};
			}
			<span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 镜像情况，将所有左、左旋，替换为右、右旋，反之亦然
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left 
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (current_node <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left) {
					current_node <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>right);
				}
				<span style="color:#66d9ef">else</span> {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">left_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>parent);
				}
			}
		}
		<span style="color:#75715e">// 针对回到根的情况，需要保证根是黑色
</span><span style="color:#75715e"></span>		(<span style="color:#f92672">*</span>root)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
	}

	<span style="color:#75715e">// 向红黑树插入数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> redblack_tree_insert(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		<span style="color:#75715e">// 空树直接插入
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!*</span>root) {
			<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">nullptr</span>, data, NODE_COLOR<span style="color:#f92672">::</span>BLACK);
			<span style="color:#66d9ef">return</span>;
		}
		<span style="color:#75715e">// 查询是否已经存在
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> query_node <span style="color:#f92672">=</span> to_rbnode(query(<span style="color:#f92672">*</span>root, data));
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>query_node<span style="color:#f92672">-&gt;</span>is_nil) {
			query_node<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">++</span>;
			<span style="color:#66d9ef">return</span>;
		}
		<span style="color:#75715e">// 不存在的情况下，query返回的是恰好可用于插入的空数据节点，提升为内部节点
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> insert_node <span style="color:#f92672">=</span> query_node;
		insert_node<span style="color:#f92672">-&gt;</span>to_inner(data);
		<span style="color:#75715e">// 恢复红黑树性质
</span><span style="color:#75715e"></span>		redblack_tree_insert_fix(root, insert_node);
	}

	<span style="color:#75715e">// 删除红黑树节点后的性质恢复
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> redblack_tree_delete_fix(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current_node) {
		<span style="color:#75715e">// 退出条件为抵达根节点，或当前节点不为黑色
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (current_node <span style="color:#f92672">!=</span> <span style="color:#f92672">*</span>root <span style="color:#f92672">&amp;&amp;</span> current_node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
			<span style="color:#66d9ef">if</span> (current_node <span style="color:#f92672">==</span> current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left) { <span style="color:#75715e">// 当前节点是左孩子
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					<span style="color:#75715e">// 情形一
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">left_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>is_nil
					<span style="color:#f92672">||</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK)) {
					<span style="color:#75715e">// 情形二
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					<span style="color:#75715e">// 情形三
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right));
					<span style="color:#66d9ef">else</span>
						right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right);
				}
				<span style="color:#66d9ef">else</span> {
					<span style="color:#75715e">// 情形四
</span><span style="color:#75715e"></span>					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color 
						<span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">left_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>RED
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">right_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>is_nil
					<span style="color:#f92672">||</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
						<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK)) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					current_node <span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent);
				}
				<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK
					<span style="color:#f92672">&amp;&amp;</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">==</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK) {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>RED;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left));
					<span style="color:#66d9ef">else</span>
						left_rotate(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left);
				}
				<span style="color:#66d9ef">else</span> {
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color 
						<span style="color:#f92672">=</span> to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					to_rbnode(current_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>root)
						<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> to_rbnode(right_rotate(current_node<span style="color:#f92672">-&gt;</span>parent));
					<span style="color:#66d9ef">else</span>
						<span style="color:#a6e22e">right_rotate</span>(current_node<span style="color:#f92672">-&gt;</span>parent);
					current_node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>root;
				}
			}
		}
		<span style="color:#75715e">// 保持根为黑，或者对当前红节点添加黑色（完成对缺失的黑色的补充）
</span><span style="color:#75715e"></span>		current_node<span style="color:#f92672">-&gt;</span>color <span style="color:#f92672">=</span> NODE_COLOR<span style="color:#f92672">::</span>BLACK;
	}

	<span style="color:#75715e">// 从红黑树中删除指定数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">bool</span> redblack_tree_delete(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node<span style="color:#f92672">=</span>to_rbnode(query(<span style="color:#f92672">*</span>root, data));
		<span style="color:#75715e">// 数据不存在
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>is_nil)
			<span style="color:#66d9ef">return</span> false;
		<span style="color:#75715e">// 数据有多份，暂时不用删除节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
			node<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">--</span>;
			<span style="color:#66d9ef">return</span> true;
		}
		<span style="color:#75715e">// 寻找删除节点
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> remove_node<span style="color:#f92672">=</span><span style="color:#66d9ef">nullptr</span>;
		<span style="color:#66d9ef">if</span> (to_rbnode(node<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>is_nil 
			<span style="color:#f92672">||</span> to_rbnode(node<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>is_nil) {
			remove_node <span style="color:#f92672">=</span> node;
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// 如果节点有双孩子，则不会被直接删除，而会被其后继节点数据替代，后继节点会被删除
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// 后继节点可以被删除的原因是，在当前节点双孩子的前提下，后继节点至多有一个右孩子
</span><span style="color:#75715e"></span>			remove_node <span style="color:#f92672">=</span> to_rbnode(successor(<span style="color:#f92672">*</span>root, node<span style="color:#f92672">-&gt;</span>data));
		}
		<span style="color:#75715e">// 寻找保留节点（后继节点的左孩子或右孩子）
</span><span style="color:#75715e"></span>		redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> save_node <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		<span style="color:#66d9ef">if</span> (to_rbnode(remove_node<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>is_nil) {
			save_node <span style="color:#f92672">=</span> to_rbnode(remove_node<span style="color:#f92672">-&gt;</span>right);
			remove_node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		}
		<span style="color:#66d9ef">else</span> {
			save_node <span style="color:#f92672">=</span> to_rbnode(remove_node<span style="color:#f92672">-&gt;</span>left);
			remove_node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
		}
		<span style="color:#75715e">// 由后继节点替代时，需要复制数据
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (remove_node <span style="color:#f92672">!=</span> node) {
			node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> remove_node<span style="color:#f92672">-&gt;</span>data;
			node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">=</span> remove_node<span style="color:#f92672">-&gt;</span>times;
		}
		<span style="color:#75715e">// 和父节点的关系重设
</span><span style="color:#75715e"></span>		save_node<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> remove_node<span style="color:#f92672">-&gt;</span>parent;
		<span style="color:#66d9ef">if</span> (remove_node<span style="color:#f92672">-&gt;</span>parent) {
			<span style="color:#75715e">// remove_node is NOT root
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (remove_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> remove_node) {
				remove_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> save_node;
			}
			<span style="color:#66d9ef">else</span> {
				remove_node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> save_node;
			}
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// 删除根节点时更新根
</span><span style="color:#75715e"></span>			<span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> save_node;
		}
		<span style="color:#75715e">// 删除了一个黑节点，部分路径黑高度减一，需要恢复性质
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(remove_node<span style="color:#f92672">-&gt;</span>color<span style="color:#f92672">==</span>NODE_COLOR<span style="color:#f92672">::</span>BLACK)
			redblack_tree_delete_fix(root, save_node);
		<span style="color:#75715e">// 移除待删除节点
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">delete</span> remove_node;
		<span style="color:#66d9ef">return</span> true;
	}

	<span style="color:#75715e">// 工具函数，打印内部节点值、颜色、父节点值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">void</span> rbtree_print(redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>root<span style="color:#f92672">==</span><span style="color:#66d9ef">nullptr</span>) {
			std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;rbtree empty&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">return</span>;
		}
		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;====rbtree start====&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
		std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>binary_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> order_list;
		inorder<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">*</span>root, order_list);
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> t : order_list) {
			std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> enum_trans(to_rbnode(t)<span style="color:#f92672">-&gt;</span>color) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;  &lt;&lt;  &#34;</span>;
			<span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>parent)
				std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">else</span>
				std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;root&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
		}
		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;====rbtree  end ====&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	}
}
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> rbtree_delete_test(lyc_algorithm<span style="color:#f92672">::</span>redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span>root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span>data) {
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	<span style="color:#66d9ef">if</span> (redblack_tree_delete<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(root, data)) {
		rbtree_print(root);
	}
	<span style="color:#66d9ef">else</span> {
		std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; not exist in rbtree&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	}
}

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> rbtree_insert_test(lyc_algorithm<span style="color:#f92672">::</span>redblack_tree_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> root, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	redblack_tree_insert<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(root, data);
	rbtree_print(root);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======tree_examples======&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	redblack_tree_node<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">10</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">11</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">1</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">5</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">0</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">17</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">14</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">13</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">12</span>);

	<span style="color:#75715e">//std::cout &lt;&lt; &#34;====rbtree_delete====&#34; &lt;&lt; std::endl;
</span><span style="color:#75715e"></span>	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">233</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">10</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">11</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">1</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">5</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">0</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">17</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">14</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">13</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">12</span>);

	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">3</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">2</span>);
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);

	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">3</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);
	rbtree_delete_test(<span style="color:#f92672">&amp;</span>root, <span style="color:#ae81ff">4</span>);


	redblack_tree_node<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;*</span> strRoot <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>strRoot, std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;233&#34;</span>));
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>strRoot, std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;666&#34;</span>));
	rbtree_insert_test(<span style="color:#f92672">&amp;</span>strRoot, std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;789&#34;</span>));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="跳跃表">跳跃表</h1>
<ol>
<li>概述：一种基于链表的，平衡、动态的搜索数据结构。相比于B树、红黑树、树堆等复杂的数据结构，跳跃表非常易于实现，而且非常容易理解和记忆。
<ul>
<li>任何操作的期望时间复杂度均为：$O(logn)$，而且其方差可以控制到非常小
<img src="https://www.lyclife.com/images/algoSeries/skiplist.svg" alt="跳跃树示意图"></li>
</ul>
</li>
<li>操作过程：
<ol>
<li>查询：
<ol>
<li>从最高层的链表开始，逐个查找直到即将超过范围，进入下一级链表</li>
<li>重复1，直到找到元素，或在最底层超出范围（即不存在该元素）</li>
</ol>
</li>
<li>插入：
<ul>
<li>利用查询寻找该元素：如果找到该元素，增加计数；否则在对应位置插入节点，并计算随机数，以1/2概率向上提升
<ul>
<li>图中6即为提升2次，1和13各提升一次</li>
</ul>
</li>
</ul>
</li>
<li>删除：
<ul>
<li>查询该元素，如果查找到，直接将该节点及其提升节点全部删除。</li>
</ul>
</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> lyc_algorithm {

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">skip_node</span> {
		skip_node<span style="color:#f92672">*</span> left, <span style="color:#f92672">*</span> right;
		<span style="color:#75715e">// 为了实现方便，这里和图中是相反的
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// upper代表节点更密集的一层，lower代表节点更稀疏的一层
</span><span style="color:#75715e"></span>		skip_node<span style="color:#f92672">*</span> upper, <span style="color:#f92672">*</span> lower;
		T value;
		std<span style="color:#f92672">::</span>size_t times;

		skip_node(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) 
			<span style="color:#f92672">:</span>value(data), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>)
			, upper(<span style="color:#66d9ef">nullptr</span>), lower(<span style="color:#66d9ef">nullptr</span>),times(<span style="color:#ae81ff">1</span>)
		{}

		skip_node()
			<span style="color:#f92672">:</span>left(<span style="color:#66d9ef">nullptr</span>),right(<span style="color:#66d9ef">nullptr</span>)
			,upper(<span style="color:#66d9ef">nullptr</span>),lower(<span style="color:#66d9ef">nullptr</span>),times(<span style="color:#ae81ff">0</span>)
		{}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">skip_list</span> {
		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> max_level;
		std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> level;
		skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> tail_pointer;

		skip_list(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> max_level <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>)
			<span style="color:#f92672">:</span>max_level(max_level),tail_pointer(<span style="color:#66d9ef">nullptr</span>)
		{
			<span style="color:#66d9ef">if</span> (max_level <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;max_level must &gt;= 1&#34;</span>);
			}
			make_new_level();
		}

		<span style="color:#f92672">~</span>skip_list() {
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> node : level) {
				<span style="color:#66d9ef">auto</span> save_node <span style="color:#f92672">=</span> node;
				<span style="color:#66d9ef">while</span> (node) {
					save_node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
					<span style="color:#66d9ef">delete</span> node;
					node <span style="color:#f92672">=</span> save_node;
				}
			}
		}

		<span style="color:#75715e">// 创建一个新的空层
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">make_new_level</span>() {
			level.push_back(<span style="color:#66d9ef">new</span> skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>());
			<span style="color:#66d9ef">auto</span> tempnode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>();
			level.back()<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> tempnode;
			tempnode<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> level.back();
			<span style="color:#66d9ef">if</span> (level.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
				level.back()<span style="color:#f92672">-&gt;</span>upper <span style="color:#f92672">=</span> level.at(level.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
				level.back()<span style="color:#f92672">-&gt;</span>upper<span style="color:#f92672">-&gt;</span>lower <span style="color:#f92672">=</span> level.back();
				tempnode<span style="color:#f92672">-&gt;</span>upper <span style="color:#f92672">=</span> tail_pointer;
				tail_pointer<span style="color:#f92672">-&gt;</span>lower <span style="color:#f92672">=</span> tempnode;
			}
			tail_pointer <span style="color:#f92672">=</span> tempnode;
		}

		<span style="color:#75715e">/*
</span><span style="color:#75715e">		* 在corner右侧，创建一个新的值节点
</span><span style="color:#75715e">		* 其上层节点为*upper_node
</span><span style="color:#75715e">		* 产生随机值new_level指示是否继续提升
</span><span style="color:#75715e">		*/</span> 
		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">make_level_node</span>(skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> corner, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data
				, skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;**</span> upper_node, <span style="color:#66d9ef">bool</span><span style="color:#f92672">&amp;</span> new_level) {
			<span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>uniform_real_distribution<span style="color:#f92672">&lt;&gt;</span> dis(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
			<span style="color:#66d9ef">auto</span> seed <span style="color:#f92672">=</span> 
				std<span style="color:#f92672">::</span>mt19937(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>system_clock<span style="color:#f92672">::</span>now().time_since_epoch().count());
			<span style="color:#66d9ef">auto</span> old_right <span style="color:#f92672">=</span> corner<span style="color:#f92672">-&gt;</span>right;
			corner<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(data);
			old_right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> corner<span style="color:#f92672">-&gt;</span>right;
			corner<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> old_right;
			corner<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> corner;
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>upper_node) {
				corner<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>upper <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>upper_node;
				(<span style="color:#f92672">*</span>upper_node)<span style="color:#f92672">-&gt;</span>lower <span style="color:#f92672">=</span> corner<span style="color:#f92672">-&gt;</span>right;
			}
			<span style="color:#f92672">*</span>upper_node <span style="color:#f92672">=</span> corner<span style="color:#f92672">-&gt;</span>right;
			new_level<span style="color:#f92672">=</span> dis(seed) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>;
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
			std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> level_corner;
			<span style="color:#66d9ef">auto</span> pos <span style="color:#f92672">=</span> lower_bound(data, level_corner);
			<span style="color:#66d9ef">if</span> (pos<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">&amp;&amp;</span>pos<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">==</span> data) {
				pos<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">++</span>;
			}
			<span style="color:#66d9ef">else</span> {
				skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> upper_node <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
				<span style="color:#66d9ef">bool</span> new_level <span style="color:#f92672">=</span> false;
				<span style="color:#75715e">// corner列表是自底向上的，提升是自顶向下的，需要反转一次
</span><span style="color:#75715e"></span>				std<span style="color:#f92672">::</span>reverse(level_corner.begin(), level_corner.end());
				<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> corner : level_corner) {
					make_level_node(corner, data, <span style="color:#f92672">&amp;</span>upper_node, new_level);
					<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>new_level)
						<span style="color:#66d9ef">break</span>;
				}
				<span style="color:#75715e">// 从此层开始是全新的层
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">while</span> (new_level <span style="color:#f92672">&amp;&amp;</span> level.size() <span style="color:#f92672">&lt;</span> max_level) {
					make_new_level();
					make_level_node(level.back(), data, <span style="color:#f92672">&amp;</span>upper_node, new_level);
				}
			}
		}

		<span style="color:#75715e">/*
</span><span style="color:#75715e">		* 不存在返回false
</span><span style="color:#75715e">		* 否则删除并返回 true
</span><span style="color:#75715e">		*/</span>
		<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
			<span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> contain(data);
			<span style="color:#66d9ef">if</span> (node <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
				node<span style="color:#f92672">-&gt;</span>times<span style="color:#f92672">--</span>;
				<span style="color:#66d9ef">return</span> true;
			}
			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (node) {
				<span style="color:#66d9ef">while</span> (node) {
					<span style="color:#66d9ef">auto</span> lower_node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>lower;
					node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
					node<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
					<span style="color:#66d9ef">delete</span> node;
					node <span style="color:#f92672">=</span> lower_node;
				}
				<span style="color:#75715e">// 检查是否有多余的空层
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (level.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
					<span style="color:#75715e">// 注意这里不能用迭代器哦，因为涉及到删除操作，迭代器会失效的
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> level.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
							; i <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> level.at(i)<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
							; <span style="color:#f92672">--</span>i) {
						tail_pointer <span style="color:#f92672">=</span> level.at(i)<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>upper;
						<span style="color:#66d9ef">delete</span> level.at(i)<span style="color:#f92672">-&gt;</span>right;
						<span style="color:#66d9ef">delete</span> level.at(i);
						level.pop_back();
					}
				}
				<span style="color:#66d9ef">return</span> true;
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">return</span> false;
			}
		}

		<span style="color:#75715e">/*
</span><span style="color:#75715e">		* 存在返回对应值
</span><span style="color:#75715e">		* 否则返回nullptr
</span><span style="color:#75715e">		*/</span>
		skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> contain(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
			<span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> lower_bound(data);
			<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">==</span> data) {
				<span style="color:#66d9ef">return</span> node;
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
			}
		}

		<span style="color:#75715e">/*
</span><span style="color:#75715e">		* 返回第一个大于等于data的值
</span><span style="color:#75715e">		* 不存在则返回最底层的哨兵
</span><span style="color:#75715e">		*/</span>
		skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> lower_bound(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
			std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> level_corner;
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lower_bound</span>(data, level_corner);
		}

		<span style="color:#75715e">/*
</span><span style="color:#75715e">		* 返回第一个大于等于data的值
</span><span style="color:#75715e">		* 同时返回查询时自底到上每一层转角值
</span><span style="color:#75715e">		* 不存在则返回最底层的哨兵
</span><span style="color:#75715e">		*/</span>
		skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> lower_bound(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;&amp;</span> level_corner) {
			skip_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> current_node <span style="color:#f92672">=</span> level.back();
			<span style="color:#66d9ef">while</span> (current_node) {
				<span style="color:#75715e">// 每一次循环开始时current_node一定位于不可能满足大于等于data的位置
</span><span style="color:#75715e"></span>				current_node <span style="color:#f92672">=</span> current_node<span style="color:#f92672">-&gt;</span>right;
				<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>times) {
					<span style="color:#75715e">//循环向右找到第一个大于等于的情况
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">while</span> (current_node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">&amp;&amp;</span> current_node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;</span> data) {
						current_node <span style="color:#f92672">=</span> current_node<span style="color:#f92672">-&gt;</span>right;
					}
					<span style="color:#75715e">//存在等于
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>times <span style="color:#f92672">&amp;&amp;</span> current_node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">==</span> data) {
						<span style="color:#66d9ef">while</span> (current_node<span style="color:#f92672">-&gt;</span>upper) {
							current_node <span style="color:#f92672">=</span> current_node<span style="color:#f92672">-&gt;</span>upper;
						}
						<span style="color:#66d9ef">return</span> current_node;
					}
					<span style="color:#66d9ef">else</span> {<span style="color:#75715e">//大于或不存在
</span><span style="color:#75715e"></span>						<span style="color:#75715e">//存在上层，继续查询
</span><span style="color:#75715e"></span>						<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>upper) {
							level_corner.push_back(current_node<span style="color:#f92672">-&gt;</span>left);
							current_node <span style="color:#f92672">=</span> current_node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>upper;
						}
						<span style="color:#66d9ef">else</span> {
							<span style="color:#75715e">//不存在上层了，确实没有该值，直接返回
</span><span style="color:#75715e"></span>							level_corner.push_back(current_node<span style="color:#f92672">-&gt;</span>left);
							<span style="color:#66d9ef">return</span> current_node;
						}
					}
				}
				<span style="color:#66d9ef">else</span> {
					<span style="color:#75715e">// 该层到哨兵了，该层不存在大于等于
</span><span style="color:#75715e"></span>					level_corner.push_back(current_node<span style="color:#f92672">-&gt;</span>left);
					<span style="color:#75715e">// 可以向上
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> (current_node<span style="color:#f92672">-&gt;</span>upper)
						current_node <span style="color:#f92672">=</span> current_node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>upper;
					<span style="color:#66d9ef">else</span>
						<span style="color:#66d9ef">return</span> current_node;
				}
			}
		}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> o, <span style="color:#66d9ef">const</span> skip_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&amp;</span> list) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> level : list.level) {
			o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;^ &#34;</span>;
			<span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> level<span style="color:#f92672">-&gt;</span>right;
			<span style="color:#66d9ef">while</span> (node) {
				<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>times) {
					o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &lt;-&gt; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>value;
				}
				<span style="color:#66d9ef">else</span> {
					o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &lt;-&gt; $&#34;</span>;
				}
				node <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
			}
			o <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
		}
		<span style="color:#66d9ef">return</span> o;
	}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	skip_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> int_skip_list;
	int_skip_list.insert(<span style="color:#ae81ff">1</span>);
	int_skip_list.insert(<span style="color:#ae81ff">2</span>);
	int_skip_list.insert(<span style="color:#ae81ff">7</span>);
	int_skip_list.insert(<span style="color:#ae81ff">11</span>);
	int_skip_list.insert(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>);
	int_skip_list.insert(<span style="color:#ae81ff">0</span>);
	int_skip_list.insert(<span style="color:#ae81ff">7</span>);
	int_skip_list.insert(<span style="color:#ae81ff">1</span>);
	int_skip_list.insert(<span style="color:#ae81ff">100</span>);
	int_skip_list.insert(<span style="color:#ae81ff">6</span>);
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> int_skip_list <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;search 6: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.contain(<span style="color:#ae81ff">6</span>)<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;search 100: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.contain(<span style="color:#ae81ff">100</span>)<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;search -7: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.contain(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>)<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 100: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">100</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 1: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 2: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 7: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">7</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 11: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">11</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove -1: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> int_skip_list <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 1: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 7: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">7</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 6: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> int_skip_list <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;remove 0: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> int_skip_list.remove(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> int_skip_list <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="b树">B树</h1>
<ul>
<li>出现背景：B树的最初出现是为了对磁盘等辅助存储设备上的数据存储而设计的一类平衡搜索树，合理使用B树能够降低磁盘IO次数。虽然目前SSD已经开始大规模普及，但考虑到价格和稳定性工业界仍然需要大量HDD的存在。
<ul>
<li>简而言之，B树的每一个节点聚合了大量的关键字，比如1000个，那么一个高度为2的B树，实际已经可以存储10亿量级的关键字，而且存取任意关键字，只需要两次读盘。</li>
<li>实现上，一个节点可以恰好构造为一个虚拟文件系统的一个页。</li>
<li>根节点一般常驻内存。</li>
<li>假定没有重复元素（大多数树都以这种条件要求，不过实现支持重复元素也很简单就是了）</li>
<li>稳定的渐进时间复杂度$O(logn)$。</li>
</ul>
</li>
<li>定义：一颗B树是具有以下性质的有根树
<ul>
<li>
<p>每个节点$x$包含域：$n[x]$(当前存储在节点x中的关键字数量)，$key_1[x]&hellip;key_{n[x]}[x]$（全部关键字，按非降序排列），$leaf[x]$（指示节点x是否为叶子节点的布尔值）。</p>
</li>
<li>
<p>指向子女的指针：$c_1[x]&hellip;c_{n[x]+1}[x]$，根据全部关键字划分，恰好为$n[x]+1$个。</p>
</li>
<li>
<p>每个叶子节点具有相同的深度，等于树的高度</p>
</li>
<li>
<p>每一个节点包含的关键字数量有上界和下界。以称$t$为B树的最小度数，则有：</p>
<ul>
<li>每个非根节点必须至少有$t-1$个关键字，至少有$t$个子女。如果树非空，根节点至少有$1$个关键字。</li>
<li>每个节点至多有$2t-1$个关键字，即至多有$2t$个子女。如果达到此最大值，称该节点是满的。</li>
</ul>
<blockquote>
<p>$t=2$时的B树最为简单，也就构成了一个2-3-4树。而红黑树和2-3-4树也有一定的关系。由此可以看出，B树、2-3-4树、红黑树，都有着一定的联系。</p>
</blockquote>
<blockquote>
<p>关于度。也有说法是阶。来自于Wikipedia的说法是，一个m阶的B树，每一个节点最多有m个子节点，每一个非根内部节点最少有$\lceil m/2 \rceil$。由于和算法导论有些出入。因此本文的描述仍然以算法导论为主。</p>
</blockquote>
</li>
</ul>
</li>
<li>基本操作：由于B树的出现和磁盘操作非常相关，因此这里也保留了读盘$\mathrm{DISK\_READ}()$、写盘$\mathrm{DISK\_WRITE}()$操作。
<ol>
<li>
<p>创建新节点：$\mathrm{ALLOCATE\_NODE}()$</p>
</li>
<li>
<p>创建空树：$\mathrm{B\_TREE\_CREATE}(T)$</p>
<ol>
<li> $\mathrm{ALLOCATE\_NODE}(x)$</li>
<li> $leaf[x] \gets true$</li>
<li> $n[x] \gets 0$</li>
<li> $DISK\_WRITE(x)$</li>
<li> $root[T]\gets x$</li>
</ol>
</li>
<li>
<p>搜索：$\mathrm{B\_TREE\_SEARCH}(x,k)$</p>
<ol>
<li> $i \gets 1$</li>
<li> $\mathbf{while} \ i \le n[x] \ and \ k &gt; key_i[x]$</li>
<li>    $\mathbf{do} \ i \gets i+1$</li>
<li> $\mathbf{if} \ i \le n[x] \ and \ k=key_i[x]$</li>
<li>    $\mathbf{then \ return}(x,i)$</li>
<li> $\mathbf{if} \ leaf[x]$</li>
<li>    $\mathbf{then \ return} \ \mathrm{NIL}$</li>
<li> $\mathbf{else}$</li>
<li>    $\mathrm{DISK\_READ}(c_i[x])$</li>
<li>    $\mathrm{B\_TREE\_SEARCH}(c_i[x],k)$</li>
</ol>
</li>
<li>
<p>插入：B_TREE_INSERT($T,k$)</p>
<p><img src="https://www.lyclife.com/images/algoSeries/BTreeSplitNode.svg" alt="B树节点分裂"></p>
<blockquote>
<p>先来思考一下插入复杂的原因哈。我们找到位置之后，如果不满，那直接插入了。否则，该节点需要分裂。更麻烦的是，该节点分裂之后，可能父节点超出了满节点的限制，父节点还需要分裂，以此向上直到根节点，都需要处理。</p>
</blockquote>
<ul>
<li>满节点分裂子程序：$\mathrm{B\_TREE\_SPLIT\_CHILD}(x,i,y)$，其中$y=c_i[x]$是$x$的一个满子节点。
<ol>
<li> $z \gets \mathrm{ALLOCATE\_NODE}()$</li>
<li> $leaf[z] \gets leaf[y]$</li>
<li> $n[z] \gets t-1$</li>
<li> $\mathbf{for} \ j \gets \mathbf{to} \ t-1$</li>
<li>    $\mathbf{do} \ key_i[z] \gets key_{j+t}[y]$</li>
<li> $\mathbf{if} \ \mathrm{not} \ leaf[y]$</li>
<li>    $\mathbf{then} \ \mathbf{for} \ j \gets 1 \ \mathbf{to} \ t$</li>
<li>        $\mathbf{do} \ c_j[z] \gets c_{j+t}[y]$</li>
<li>  $n[y] \gets t-1$</li>
<li>  $\mathbf{for} \ j \gets n[x] + 1 \ \mathbf{downto} \ i + 1 $</li>
<li>    $\mathbf{do} \ c_{j+1}[x] \gets c_j[x]$</li>
<li>  $key_i[x] \gets key_t[x]$</li>
<li>  $n[x] \gets n[x] + 1$</li>
<li>  $\mathrm{DISK\_WRITE}(y)$</li>
<li>  $\mathrm{DISK\_WRITE}(z)$</li>
<li>  $\mathrm{DISK\_WRITE}(x)$</li>
</ol>
<blockquote>
<p>简单总结：由于满节点关键字一定是奇数个。分裂将满节点的中间的关键字提升到父节点，其余关键字一半一半。</p>
</blockquote>
</li>
<li>非满节点插入子程序：$\mathrm{B\_TREE\_INSERT\_NONFULL}(x,k)$
<ol>
<li>  $i \gets n[x]$</li>
<li>  $\mathbf{if} \ leaf[x]$</li>
<li>  $\mathbf{then}$</li>
<li>    $\mathbf{while} \ i \ge 1 \ \mathrm{and} \ k &lt; key_i[x]$</li>
<li>    $\mathbf{do}$</li>
<li>      $key_{i+1}[x] \gets key_i[x]$</li>
<li>      $i \gets i-1$</li>
<li>    $key_{i+1}[x] \gets k$</li>
<li>    $n[x] \gets n[x]+1$</li>
<li>    $\mathrm{DISK\_WRITE}(x)$</li>
<li>  $\mathbf{else}$</li>
<li>    $\mathbf{while} \ i \ge 1 \ and \ k &lt; key_i[x]$</li>
<li>    $\mathbf{do}$</li>
<li>      $i \gets i-1$</li>
<li>    $i \gets i+1$</li>
<li>    $\mathrm{DISK\_READ}(c_i[x])$</li>
<li>    $\mathbf{if} \ n[c_i[x]]  = 2t-1$</li>
<li>    $\mathbf{then}$</li>
<li>      $\mathrm{B\_TREE\_SPLIT\_CHILD}(x,i,c_i[x])$</li>
<li>      $\mathbf{if} \ k &gt; key_i[x]$</li>
<li>      $\mathbf{then}$</li>
<li>        $i \gets i+1$</li>
<li>    $\mathrm{B\_TREE\_INSERT\_NONFULL}(c_i[x],k)$</li>
</ol>
<blockquote>
<p>简单总结：非满叶子节点直接插入即可；而非满内节点，需要查找合适关键字位置，如果发现其位于满节点，则进行一次分裂（算法保证当前节点非满，分裂一定可以进行），并继续向下遍历子树。</p>
</blockquote>
</li>
<li>节点插入：$\mathrm{B\_TREE\_INSERT}(T,k)$
<ol>
<li>  $r \gets root[T]$</li>
<li>  $\mathbf{if} \ n[r]=2t-1$</li>
<li>  $\mathbf{then}$</li>
<li>    $s \gets \mathrm{ALLOCATE\_NODE}()$</li>
<li>    $root[T] \gets s$</li>
<li>    $leaf[s] \gets \mathrm{FALSE}$</li>
<li>    $n[s] \gets 0$</li>
<li>    $c_1[x] \gets r$</li>
<li>    $\mathrm{B\_TREE\_SPLIT\_CHILD}(s,1,r)$</li>
<li>    $\mathrm{B\_TREE\_INSERT\_NONFULL}(s,k)$</li>
<li>  $\mathbf{else}$</li>
<li>    $\mathrm{B\_TREE\_INSERT\_NONFULL}(r,k)$</li>
</ol>
<blockquote>
<p>B树的操作推崇提高磁盘效率（不要回溯）。因此插入的过程是单程下行遍历树的。这也代表节点的分裂是从根开始的，自顶向下进行。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>删除：$\mathrm{B\_TREE\_DELETE}(x,k)$</p>
<blockquote>
<p>删除操作与插入类似，但是更为复杂。从插入操作的非满节点插入子程序可以发现，新节点的插入一定是在叶子节点中进行的。但删除操作则不是，删除可以发生在任何位置。</p>
</blockquote>
<ul>
<li>整体保证：对节点$x$递归向下调用（注意是说如果发生了向下调用）$\mathrm{B\_TREE\_DELETE}(x,k)$后，$x$的关键字个数都至少等于最小度数$t$（而不是$t-1$)。这种保证能够提高效率，减少回溯。</li>
</ul>
<p><img src="https://www.lyclife.com/images/algoSeries/BTreeDelete.svg" alt="BTree删除节点的情况示例"></p>
 <center>$t=3$的BTree的删除示例</center></br>
<ol>
<li>情况一：如果关键字在节点$x$中，而且$x$是个叶子节点，则从$x$中删除k。</li>
<li>情况二：如果关键字在节点$x$中，而且$x$是个内节点，则再分以下情况讨论：
<ol>
<li>情况A：如果节点$x$内，$k$和$k$前面的关键字之间的子节点$y$包含至少$t$个关键字，则找出$y$为根的子树中的$k$的前驱$k'$，删除$k'$，并在$x$中，用$k'$替代$k$。</li>
<li>情况B：对称的，如果节点$x$内，$k$和$k$后面的关键字之间的子节点$y$包含至少$t$个关键字，则找出$y$为根的子树中的$k$的后继$k'$，删除$k'$，并在$x$中，用$k'$替代$k$。</li>
<li>情况C：否则，意味着$k$前后关键字之间的子节点的关键字数量均小于等于$t-1$个，将这两个子节点合并为新节点$z$，删除$k$，并修改子节点指针指向$z$。</li>
</ol>
</li>
<li>情况三：如果关键字不在当前内结点$x$中，则先确定包含$k$的子树的根$c_i[x]$。如果$c_i[x]$只有$t-1$个关键字，分以下情况讨论之后再递归下降到一个合适的节点进行删除。
<ol>
<li>情况A：如果$c_i[x]$只包含$t-1$个关键字，但它的一个相邻兄弟包含至少$t$个关键字，则将$x$中的某一个关键字下降至$c_i[x]$中，将$c_i[x]$相邻的兄弟节点中的某一个关键字升至$x$，将该兄弟中合适的子女指针移动到$c_i[x]$中。</li>
<li>情况B：如果$c_i[x]$以及它的所有相邻兄弟都只有$t-1$个关键字，则将$c_i[x]$和一个兄弟合并，并将$x$的一个关键字移动至新合并的节点，并使之成为改节点正中间的关键字。</li>
<li>经过A、B处理后，调用$\mathrm{B\_TREE\_DELETE}(c_i[x],k)$</li>
</ol>
</li>
</ol>
<ul>
<li>说明：各种情况ABC，都是为了防止删除导致出现过小的$n[x]$，保证B树依然维持原有的性质。结合图例，注意理解：删除$F$时不需要将$CGMTX$合并，是因为$DEF$并没有再递归下降，函数执行到这里，删除掉$F$就返回了。而删除$D$的时候就正好满足情况三的要求，而且触发了删除根$P$。也就是正确理解三种情况的考虑顺序。只有当需要出现递归下降时，才需要进行一次情况三的考虑。</li>
</ul>
</li>
</ol>
</li>
<li>实际应用：MySQL等数据库的存储引擎，以及其他各类应用中，实际更经常使用的是B树的变种B+树、B*树。
<ul>
<li>B+树定义（和B树不同的）：
<ol>
<li>数据仅存在于叶节点，内部节点仅用于检索。（内存可以容纳更多的索引）</li>
<li>叶子节点的兄弟节点之间存在指针相连。（更便于对节点的顺序遍历）</li>
<li>内部节点的孩子指针数量和关键字数量相同。$c_i[x]$子树范围为$[Key_i[x],Key_{i+1}[x])$，作为对比，B-Tree则是开区间。</li>
<li>分裂操作：当一个节点满时，分配新节点，并将原节点中一般的数据复制到新节点。</li>
</ol>
</li>
<li>B*树定义（和B+树不同的）：
<ol>
<li>非根内部节点的兄弟之间也有指针连接。</li>
<li>分裂操作：当一个节点满时，如果递增方向的兄弟节点未满，则转移一部分给兄弟节点，并修改父节点中的对应关键字，如果递增方向的兄弟节点也满了，则在二者之间新增节点，并各复制$1/3$的数据给新节点，父节点增加关键字。（非根节点的最低利用率由$1/2$上升到$2/3$）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="树堆treap">树堆（Treap）</h1>
<ul>
<li>定义： 每一个节点除了关键字以外，还有一个随机值作为优先级。使得整棵树不仅在关键字上满足二叉搜索树的定义，同时在该随机优先级值上满足大顶堆（小顶堆也行）的性质。即树（Tree）和堆（Heap）的组合，树堆（Treap）。</li>
<li>性能：期望时间复杂度$O(logn)$。
<ul>
<li>相较于其他平衡二叉搜索树，实现相对更为简单，且基本能实现随机平衡的结构。</li>
</ul>
</li>
<li>操作：
<ol>
<li>插入：
<ol>
<li>将新关键字插入到满足二叉搜索树要求的位置</li>
<li>赋予新节点随机值作为优先级</li>
<li>从新节点自底向上递归，使用左旋或右旋使针对优先级满足大顶堆性质</li>
</ol>
</li>
<li>删除：
<ol>
<li>找到待删除节点</li>
<li>将该节点和子节点比较，向下进行左旋或者右旋</li>
<li>循环进行步骤2，直到该节点变换到叶子节点，删除</li>
</ol>
</li>
<li>查找：和普通二叉搜索树一致</li>
</ol>
</li>
</ul>
<h1 id="可合并堆">可合并堆</h1>
<ul>
<li>可合并堆：支持如下操作的数据结构：
<ul>
<li>创建并返回空的新堆</li>
<li>向堆中插入关键字</li>
<li>返回指向堆中最小关键字节点的指针</li>
<li>将堆中包含最小关键字的节点从堆中删除，返回其指针</li>
<li>将两个堆合并</li>
</ul>
<blockquote>
<p>默认的可合并堆都是最小堆</p>
</blockquote>
</li>
<li>性能对比
<table>
<thead>
<tr>
<th>操作</th>
<th>二叉堆（最坏情况）</th>
<th>二项堆（最坏情况）</th>
<th>斐波那契堆（均摊）</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>建堆</td>
<td>$\Theta(1)$</td>
<td>$\Theta(1)$</td>
<td>$\Theta(1)$</td>
<td></td>
</tr>
<tr>
<td>插入</td>
<td>$\Theta(logn)$</td>
<td>$\Omega(logn)$</td>
<td>$\Theta(1)$</td>
<td></td>
</tr>
<tr>
<td>返回最小元素</td>
<td>$\Theta(1)$</td>
<td>$\Omega(logn)$</td>
<td>$\Theta(1)$</td>
<td></td>
</tr>
<tr>
<td>抽取最小元素</td>
<td>$\Theta(logn)$</td>
<td>$\Theta(logn)$</td>
<td>$\mathrm{O}(logn)$</td>
<td></td>
</tr>
<tr>
<td>合并堆</td>
<td>$\Theta(n)$</td>
<td>$\Omega(logn)$</td>
<td>$\Theta(1)$</td>
<td></td>
</tr>
<tr>
<td>减小关键字</td>
<td>$\Theta(logn)$</td>
<td>$\Theta(logn)$</td>
<td>$\Theta(1)$</td>
<td></td>
</tr>
<tr>
<td>删除关键字</td>
<td>$\Theta(logn)$</td>
<td>$\Theta(logn)$</td>
<td>$\mathrm{O}(logn)$</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>图例
<img src="https://www.lyclife.com/images/algoSeries/binomailHeap_fiboHeap.svg" alt="二项堆和斐波那契堆示意图"></li>
</ul>
<center>二项堆(上)和斐波那契堆(下)示意图。注：红色代表标记</center>
<h1 id="二项堆">二项堆</h1>
<ul>
<li>定义
<ul>
<li>二项树：一种递归定义的有序树
<ul>
<li>二项树$B_0$只包含一个节点</li>
<li>二项树$B_k$由两棵二项树$B_{k-1}$连接而成，其中一棵树的根是另一棵树的根的最左孩子</li>
</ul>
</li>
<li>二项树$B_k$的性质：
<ul>
<li>共有$2^k$个节点</li>
<li>树的高度为k</li>
<li>在深度$i$处，恰好有$\binom{k}{i}$个节点。$i=0,1,2,&hellip;k$</li>
<li>根的度数为$k$，是树中的最大度数，并且根的子女从左至右依次是二项树$B_{k-1},B_{k-2}&hellip;B_0$的根。</li>
<li>二项树是左偏的（树中的任何一个子树，左侧子树节点多于右侧兄弟子树节点）</li>
</ul>
</li>
<li>二项堆：由满足以下性质的二项树组成
<ul>
<li>二项堆中的每个二项树遵循最小堆性质，节点的关键字不小于父节点关键字。即二项树是最小堆有序的。</li>
<li>对任意非负整数$k$，在二项堆中至多有一棵二项树的根具有度数$k$。
<ul>
<li>即一个包含$n$个节点的二项堆中，包含至多$\lfloor logn \rfloor +1$棵二项树。关于这一点的理解，可以参考二进制编码。数字$n$的二进制编码有$\lfloor logn \rfloor +1$位，记作$&lt; b_{\lfloor logn \rfloor},b_{\lfloor logn \rfloor -1},&hellip;,b_0 &gt;$，有$n=\sum_{i=0}^{\lfloor logn \rfloor}b_i2^i$，恰好可将和式中的每一项视为一个二项树。</li>
</ul>
</li>
</ul>
</li>
<li>二项堆的表示：
<ul>
<li>每个二项树节点$x$的域：
<ul>
<li>父节点指针：$p[x]$</li>
<li>最左孩子的指针：$child[x]$</li>
<li>指向紧右兄弟的指针：$sibling[x]$</li>
<li>子女数量（度）：$degree[x]$</li>
</ul>
</li>
<li>二项堆$H$的表示：
<ul>
<li>首个二项树的根：$head[H]$</li>
<li>根表（包含各二项树的根的链表）：$sibling[x]$
<ul>
<li>就是各根节点的紧右兄弟的指针</li>
<li>根表中各根的度数严格递增（和非根节点的$sibling[x]$域的特点相反）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在可合并堆基础上的额外操作：
<ul>
<li>减少关键字的大小</li>
<li>删除某个关键字</li>
</ul>
</li>
</ul>
</li>
<li>操作：
<ol>
<li>
<p>创建新堆：$\mathrm{MAKE\_BINOMAIL\_HEAP}()$</p>
</li>
<li>
<p>寻找最小关键字：$\mathrm{BINOMAIL\_HEAP\_MINIMUM}(H)$</p>
<ul>
<li>从$head[H]$开始，沿着根表寻找最少值</li>
</ul>
</li>
<li>
<p>合并两个二项堆：$\mathrm{BINOMAIL\_HEAP\_UNION}(H_1,H_2)$</p>
<ul>
<li>
<p>两棵$B_{k-1}$树的合并子程序：$\mathrm{BINOMAIL\_LINK}(y,z)$</p>
<ol>
<li>  $p[y] \gets z$</li>
<li>  $sibling[y] \gets child[z]$</li>
<li>  $child[z] \gets y$</li>
<li>  $degree[z] \gets degree[z] + 1$</li>
</ol>
<blockquote>
<p>$y$成为了$z$的最左孩子</p>
</blockquote>
</li>
<li>
<p>根表合并子程序：$\mathrm{BINOMAIL\_HEAP\_MERGE}(H_1,H_2)$</p>
<ol>
<li>  $x \gets head[H_1]$</li>
<li>  $y \gets head[H_2]$</li>
<li>  $root \gets \mathrm{NIL}$</li>
<li>  $current \gets \&amp;root$</li>
<li>  $\mathbf{while} \ x \ne \mathrm{NIL \ and} \ y \ne \mathrm{NIL}$</li>
<li>  $\mathbf{do}$</li>
<li>    $\mathbf{if} \ degree[x] &lt; degree[y]$</li>
<li>    $\mathbf{then}$</li>
<li>      $sibling[*current] \gets x$</li>
<li>      $x \gets sibling[x]$</li>
<li>    $\mathbf{else}$</li>
<li>      $sibling[*current] \gets y$</li>
<li>      $y \gets sibling[y]$</li>
<li>    $current \gets \&amp;sibling[*current]$</li>
<li>  $\mathbf{if} x \ne \mathrm{NIL}$</li>
<li>    $sibling[*current] \gets x$</li>
<li>  $\mathbf{else}$</li>
<li>    $sibling[*current] \gets y$</li>
<li>  $\mathbf{return} \ root$</li>
</ol>
<blockquote>
<p>注：1.伪代码中的*和&amp;为C/C++语法中的取地址和解引用运算。2.根表合并只保证根表中的度数单调不递减。</p>
</blockquote>
</li>
<li>
<p>二项堆合并程序：$\mathrm{BINOMAIL\_HEAP\_UNION}(H_1,H_2)$</p>
<ol>
<li>  $H \gets \mathrm{MAKE\_BINOMAIL\_HEAP}()$</li>
<li>  $head[H] \gets \mathrm{BINOMAIL\_HEAP\_MERGE}(H_1,H_2)$</li>
<li>  $\mathbf{if} \ head[H] = \mathrm{NIL}$</li>
<li>  $\mathbf{then}$</li>
<li>    $\mathbf{return} \ H$</li>
<li>  $prev\_x \gets NIL$</li>
<li>  $x \gets head[H]$</li>
<li>  $next\_x \gets sibling[x]$</li>
<li>  $\mathbf{while} \ next\_x \ne \mathrm{NIL}$</li>
<li>  $\mathbf{do}$</li>
<li>    $\mathbf{if} (degree[x] \ne degree[next\_x])$</li>
<li>      $\mathrm{or} \ (sibling[next\_x] \ne \mathrm{NIL} \ \mathrm{and}$</li>
<li>       $degree[sibling[next\_x]]=degree[x])$</li>
<li>    $\mathbf{then}$</li>
<li>      $prev\_x \gets x$</li>
<li>      $x \gets next\_x$</li>
<li>    $\mathbf{else \ if} \ key[x] \le key[next\_x]$</li>
<li>    $\mathbf{then}$</li>
<li>      $sibling[x] \gets sibling[next\_x]$</li>
<li>      $\mathrm{BINOMAIL\_LINK}(next\_x,x)$</li>
<li>    $\mathbf{else}$</li>
<li>      $\mathbf{if} \ prev\_x = \mathrm{NIL}$</li>
<li>         $head[H] \gets next\_x$</li>
<li>      $\mathbf{else}$</li>
<li>        $sibling[prev\_x] \gets next\_x$</li>
<li>      $\mathrm{BINOMAIL\_LINK}(x,next\_x)$</li>
<li>      $x \gets next\_x$</li>
<li>    $next\_x \gets sibling[x]$</li>
<li>  $\mathbf{return} \ H$</li>
</ol>
<blockquote>
<p>情况说明</p>
</blockquote>
<ol>
<li>情况一（第14行）：虽然刚合并的根表不会出现多于2个的重复度数的根，但是在逐渐合并根的过程中，会出现至多3个重复度数的根。此时第一个根被保留，第二个第三个后续进行合并。</li>
<li>情况二（第17行）：合并根节点需要满足最小堆性质</li>
<li>情况三（第22行）：比较大小后，根据需要更换二项堆的根节点，或者调整前后的兄弟关系，最后合并根节点。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>插入一个节点：$\mathrm{BINOMAIL\_HEAP\_INSERT}(H,x)$</p>
<ol>
<li>  $H' \gets \mathrm{MAKE\_BINOMAIL\_HEAP}()$</li>
<li>  $p[x] \gets \mathrm{NIL}$</li>
<li>  $child[x] \gets \mathrm{NIL}$</li>
<li>  $sibling[x] \gets \mathrm{NIL}$</li>
<li>  $degree[x] \gets 0$</li>
<li>  $head[H'] \gets x$</li>
<li>  $H \gets \mathrm{BINOMAIL\_HEAP\_UNION}(H,H')$</li>
</ol>
<blockquote>
<p>插入节点等价于：创建一个新的单点构成的堆，并和已有堆合并</p>
</blockquote>
</li>
<li>
<p>抽取具有最小关键字的节点：$\mathrm{BINOMAIL\_HEAP\_EXTRACT\_MIN}(H)$</p>
<ol>
<li>  找到最小关键字节点（必在二项堆根表中）$x$</li>
<li>  从根表中移除$x$</li>
<li>  $H' \gets \mathrm{MAKE\_BINOMAIL\_HEAP}()$</li>
<li>  反转$x$的孩子节点的链表，记为$head\_child\_x$</li>
<li>  $head[H'] \gets head\_child\_x$</li>
<li>  $H \gets \mathrm{BINOMAIL\_HEAP\_UNION}(H,H')$</li>
<li>  $\mathbf{return} \ x$</li>
</ol>
<blockquote>
<p>其实就是通过反转一次链表，将$x$的孩子们恰好组成一个二项堆，并和已有二项堆合并</p>
</blockquote>
</li>
<li>
<p>将关键字的值由$x$减小为$k$：$\mathrm{BINOMAIL\_HEAP\_DECREASE\_KEY}(H,x,k)$</p>
<ol>
<li>  $\mathbf{if} \ k &gt; key[x]$</li>
<li>    $\mathbf{error}$</li>
<li>  $key[x] \gets k$</li>
<li>  $y \gets x$</li>
<li>  $z \gets p[y]$</li>
<li>  $\mathbf{while} \ z \ne \mathrm{NIL} \ and \ key[y] &lt; key[z]$</li>
<li>  $\mathbf{do}$</li>
<li>    $exchange \ key[y] \leftrightarrow key[z]$</li>
<li>    如果y、z有卫星数据，一并交换</li>
<li>    $y \gets z$</li>
<li>    $z \gets p[y]$</li>
</ol>
<blockquote>
<p>关键字减小，只需要自底向上，不断和父节点比较大小并交换即可。</p>
</blockquote>
</li>
<li>
<p>删除一个关键字：$\mathrm{BINOMAIL\_HEAP\_DELETE}(H,x)$</p>
<ol>
<li>  $\mathrm{BINOMAIL\_HEAP\_DECREASE\_KEY}(H,x,-\infty)$</li>
<li>  $\mathrm{BINOMAIL\_HEAP\_EXTRACT\_MIN}(H)$</li>
</ol>
<blockquote>
<p>删除关键字相当于，先把该关键字变为无穷小（称为最小元素），再从二项堆中提取最小元素。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h1 id="斐波那契堆">斐波那契堆</h1>
<ul>
<li>也是可合并堆的一种，提供可合并堆的各类操作。为了改善时间夫再度，斐波那契堆以均摊分析为指导，维护一个稍显宽松的二项堆。理论上，使用斐波那契堆作为基础数据结构能够改善很多算法（但实际常数因子可能稍高）。</li>
<li>定义：
<ul>
<li>由一组最小堆有序树构成，但堆中的树并不一定是二项树。</li>
<li>每一个节点的域：
<ul>
<li>指向父节点：$p[x]$</li>
<li>指向任意一个子女：$child[x]$</li>
<li>指向前后兄弟：$left[x],right[x]$</li>
<li>度数：$degree[x]$</li>
<li>标记：$mark[x]$指示$x$从上一次成为某个节点的子女之后，是否失去过一个子女节点。</li>
</ul>
</li>
<li>堆的域：
<ul>
<li>指向包含最小关键字的树根：$min[H]$</li>
<li>堆中节点个数：$n[H]$</li>
</ul>
</li>
<li>斐波那契堆中的树是无序的（即各数之间没有度数单调的要求，且同一层的子树也没有度数单调的要求）</li>
</ul>
</li>
<li>分析：
<ul>
<li>根表中的树的数量：$t(H)$</li>
<li>堆中有标记节点的数量：$m(H)$</li>
<li>势函数：
$\Phi(H)=t(H)+2m(H)$</li>
<li>最大度数的上界：$D(n)$
<ul>
<li>当斐波那契堆只需支持可合并堆的操作时：$D(n) \le \lfloor logn \rfloor$</li>
<li>当斐波那契堆还需要支持减少关键字和删除关键字时：$D(n) = O(logn)$</li>
</ul>
</li>
</ul>
</li>
<li>操作的复杂度分析
<ol>
<li>创建新堆：
<ul>
<li>流程：直接创建</li>
<li>势函数变化：无，均摊代价为$O(1)$</li>
</ul>
</li>
<li>插入节点：
<ul>
<li>流程：直接将节点插入根表</li>
<li>势函数变化：$\Delta\Phi(H)=((t(H)+1)+2m(H))-(t(H)+2m(H))=1$，均摊代价仍为$O(1)$</li>
</ul>
</li>
<li>寻找最小节点：
<ul>
<li>流程：直接返回$min[H]$</li>
<li>势函数变化：无，均摊代价为$O(1)$</li>
</ul>
</li>
<li>合并两个斐波那契堆：
<ul>
<li>流程：直接链接两个堆的根表，保留最小的$min[H]$作为新的根</li>
<li>势函数变化：$\Delta\Phi(H)=\Phi(H)-(\Phi(H_1)+\Phi(H_2))=0$，均摊代价仍为$O(1)$。（本质上两个堆合并，其根表中树的总量、有标记节点的数量都没有变化。）</li>
</ul>
</li>
<li>抽取最小节点：
<ul>
<li>流程：从跟表中断开$min[H]$，将$min[H]$原子节点层提升到根表内。进行一次consolidate操作（从任意根表结点开始，合并根表节点称为最小堆无序树，最终使新根表中不再有重复度数的根）</li>
<li>势函数变化：$\Delta\Phi(H) = ((D(n)+1)+2m(H))-(t(H)+2m(H)) = O(t(H))-t(H)$
<ul>
<li>均摊代价还要考虑其他操作，至多为$O(D(n)+t(H))+\Delta\Phi(H) = O(D(n))+O(t(H))-t(H)=O(D(n))$</li>
</ul>
</li>
<li>详细解释：
<ol>
<li>在抽取过程中，首先需要处理$min[H]$的至多$D(n)$个子女，再加上断开根表的$O(1)$，以及consolidate过程$O(?)$，总时间代价为$O(D(n)+?)$。</li>
<li>仔细分析consolidate过程，根表大小此时至多为$D(n)+t(H)-1$。虽然是两层循环，但是每一次内层循环被调用时，根表大小都会下降，因此实际仍为单次扫描的时间。总体时间可视为$O(D(n)+t(H))$。</li>
<li>综上一次合并的时间代价为$O(D(n)+t(H))$。</li>
<li>均摊代价最终结果为$O(D(n))$，而由最大度数的上界的性质可知，该值为$O(logn)$。</li>
</ol>
</li>
</ul>
</li>
<li>减小关键字：
<ul>
<li>流程：直接修改关键字，如果违反最小堆要求，则和父节点断开链接，当前关键字进入根表，如有需要替换$min[H]$。并对父节点递归向上，检查是否需要级联断开（检查标记）。</li>
<li>势函数变化：假设整个过程中，有$c$个节点被断开，并因此进入根表。则树的数量至多+c，标记的数量至少下降-(c-1)+1（关键字所在节点原来就没标记，最后一个节点增加标记）。此时变化至多为，$\Delta\Phi(H)=((t(H)+c)+2(m(H)-c+2))-(t(H)+2m(H))=4-c。
<ul>
<li>实际代价：修改关键字、断开链接、进入根表$O(1)$。级联删除$O(c)$。</li>
<li>均摊代价：$O(c)+4-c=O(1)$</li>
</ul>
</li>
</ul>
</li>
<li>删除节点：
<ul>
<li>流程：和二项堆一样，减少关键字和抽取最小节点相结合</li>
<li>均摊代价：两者的结合，$O(logn)$</li>
</ul>
</li>
</ol>
</li>
<li>代码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;exception&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> lyc_algorithm {
	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">fibo_heap_node</span> {
		fibo_heap_node<span style="color:#f92672">*</span> left, <span style="color:#f92672">*</span> right, <span style="color:#f92672">*</span> parent, <span style="color:#f92672">*</span> child;
		size_t degree;
		<span style="color:#66d9ef">bool</span> mark;
		T value;
		
		fibo_heap_node()
			<span style="color:#f92672">:</span>left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>)
			, parent(<span style="color:#66d9ef">nullptr</span>), child(<span style="color:#66d9ef">nullptr</span>)
			, mark(false), degree(<span style="color:#ae81ff">0</span>) {}

		fibo_heap_node(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value, fibo_heap_node<span style="color:#f92672">*</span> parent<span style="color:#f92672">=</span><span style="color:#66d9ef">nullptr</span>)
			<span style="color:#f92672">:</span>left(<span style="color:#66d9ef">this</span>), right(<span style="color:#66d9ef">this</span>), parent(parent)
			, child(<span style="color:#66d9ef">nullptr</span>), value(value)
			, mark(false), degree(<span style="color:#ae81ff">0</span>) {

		}
	};

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">fibo_heap</span> {
	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
		fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> min_root;
		size_t n;


		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">consolidate</span>() {
			<span style="color:#75715e">// 临时数组中存储了按度为下标的当前的根表
</span><span style="color:#75715e"></span>			std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> root_degree_list(log2(n)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">nullptr</span>);
			std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> root_list;
			<span style="color:#75715e">// 由于根表将会变动，因此提前保存
</span><span style="color:#75715e"></span>			root_list.push_back(min_root);
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> root_node <span style="color:#f92672">=</span> min_root<span style="color:#f92672">-&gt;</span>right
				; root_node <span style="color:#f92672">!=</span> min_root
				; root_node <span style="color:#f92672">=</span> root_node<span style="color:#f92672">-&gt;</span>right) {
				root_list.push_back(root_node);
			}
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> root_node : root_list) {
				<span style="color:#66d9ef">auto</span> current_root <span style="color:#f92672">=</span> root_node;
				<span style="color:#66d9ef">auto</span> degree <span style="color:#f92672">=</span> current_root<span style="color:#f92672">-&gt;</span>degree;
				<span style="color:#75715e">// 处理重复度数的根
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">for</span> (; root_degree_list[degree];) {
					<span style="color:#66d9ef">auto</span> another_root <span style="color:#f92672">=</span> root_degree_list[degree];
					<span style="color:#66d9ef">if</span> (current_root<span style="color:#f92672">-&gt;</span>value<span style="color:#f92672">&gt;</span>another_root<span style="color:#f92672">-&gt;</span>value) {
						<span style="color:#75715e">// 交换指针
</span><span style="color:#75715e"></span>						std<span style="color:#f92672">::</span>swap(current_root, another_root);
					}
					<span style="color:#75715e">// 将较小的作为根
</span><span style="color:#75715e"></span>					link(current_root, another_root);
					<span style="color:#75715e">// 清空该度数的根，继续查找更大的度数是否有重复的根
</span><span style="color:#75715e"></span>					root_degree_list[degree] <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
					degree<span style="color:#f92672">++</span>;
				}
				root_degree_list[current_root<span style="color:#f92672">-&gt;</span>degree] <span style="color:#f92672">=</span> current_root;
			}
			min_root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
			<span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">!=</span> root_degree_list.size(); <span style="color:#f92672">++</span>i) {
				<span style="color:#66d9ef">if</span> (root_degree_list[i]){
					<span style="color:#75715e">// 重建根表
</span><span style="color:#75715e"></span>					root_degree_list[i]<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
					<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>min_root) {
						min_root <span style="color:#f92672">=</span> root_degree_list[i];
						min_root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> min_root;
						min_root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> min_root;
					}
					<span style="color:#66d9ef">else</span> {
						<span style="color:#66d9ef">auto</span> left <span style="color:#f92672">=</span> min_root<span style="color:#f92672">-&gt;</span>left;
						left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> root_degree_list[i];
						root_degree_list[i]<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
						min_root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> root_degree_list[i];
						root_degree_list[i]<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> min_root;
					}
					<span style="color:#75715e">// 记录斐波那契堆的根
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span>(root_degree_list[i]<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;</span> min_root<span style="color:#f92672">-&gt;</span>value) {
						min_root <span style="color:#f92672">=</span> root_degree_list[i];
					}
				}
			}
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">link</span>(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> root, fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> child) {
 			<span style="color:#75715e">// 将child作为root的子节点
</span><span style="color:#75715e"></span>			child<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>right;
			child<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>left;
			<span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>child) {
				<span style="color:#66d9ef">auto</span> left <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>child<span style="color:#f92672">-&gt;</span>left;
				left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child;
				child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
				child<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>child;
				root<span style="color:#f92672">-&gt;</span>child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child;
			}
			<span style="color:#66d9ef">else</span> {
				root<span style="color:#f92672">-&gt;</span>child <span style="color:#f92672">=</span> child;
				child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child;
				child<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child;
			}
			child<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> root;
			child<span style="color:#f92672">-&gt;</span>mark <span style="color:#f92672">=</span> false;
			root<span style="color:#f92672">-&gt;</span>degree<span style="color:#f92672">++</span>;
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cut</span>(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> child, fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent) {
			<span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>child <span style="color:#f92672">==</span> child) {
				parent<span style="color:#f92672">-&gt;</span>child <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>right;
			}
			<span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>child <span style="color:#f92672">==</span> child) {
				parent<span style="color:#f92672">-&gt;</span>child <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
			}
			<span style="color:#75715e">// 调整将删除的子节点的兄弟关系
</span><span style="color:#75715e"></span>			child<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>right;
			child<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>left;
			<span style="color:#75715e">// 移动子节点到根表
</span><span style="color:#75715e"></span>			child<span style="color:#f92672">-&gt;</span>parent <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
			child<span style="color:#f92672">-&gt;</span>mark <span style="color:#f92672">=</span> false;
			<span style="color:#66d9ef">auto</span> left <span style="color:#f92672">=</span> min_root<span style="color:#f92672">-&gt;</span>left;
			left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child;
			child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
			child<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> min_root;
			min_root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child;
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cascade_cut</span>(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node) {
			<span style="color:#66d9ef">auto</span> parent <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>parent;
			<span style="color:#66d9ef">if</span> (parent) {
				<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>parent<span style="color:#f92672">-&gt;</span>mark) {
					parent<span style="color:#f92672">-&gt;</span>mark <span style="color:#f92672">=</span> true;
				}
				<span style="color:#66d9ef">else</span> {
					cut(node, parent);
					cascade_cut(parent);
				}
			}
		}

	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
		fibo_heap()
			<span style="color:#f92672">:</span>min_root(<span style="color:#66d9ef">nullptr</span>), n(<span style="color:#ae81ff">0</span>) {}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node) {
			node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node;
			node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;
			<span style="color:#66d9ef">if</span> (min_root) {
				<span style="color:#66d9ef">auto</span> left <span style="color:#f92672">=</span> min_root<span style="color:#f92672">-&gt;</span>left;
				left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;
				node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
				node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> min_root;
				min_root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node;
				<span style="color:#66d9ef">if</span> (min_root<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>value) {
					min_root <span style="color:#f92672">=</span> node;
				}
			}
			<span style="color:#66d9ef">else</span> {
				min_root <span style="color:#f92672">=</span> node;
			}
			n<span style="color:#f92672">++</span>;
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> key) {
			<span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(key);
			insert(node);
		}

		T <span style="color:#a6e22e">get_minimum</span>() {
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>min_root)
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;empty fibo heap&#34;</span>);
			<span style="color:#66d9ef">return</span> min_root<span style="color:#f92672">-&gt;</span>value;
		}

		<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
			<span style="color:#66d9ef">return</span> min_root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>;
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(fibo_heap<span style="color:#f92672">&amp;</span> other) {
			<span style="color:#66d9ef">if</span> (other.empty()) {
				<span style="color:#66d9ef">return</span>;
			}
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>min_root) {
				min_root <span style="color:#f92672">=</span> other.min_root;
			}
			<span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">auto</span> left <span style="color:#f92672">=</span> min_root<span style="color:#f92672">-&gt;</span>left;
				<span style="color:#66d9ef">auto</span> other_left <span style="color:#f92672">=</span> other.min_root<span style="color:#f92672">-&gt;</span>left;
				left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> other.min_root;
				other.min_root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
				min_root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> other_left;
				other_left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> min_root;
				<span style="color:#66d9ef">if</span> (min_root<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&gt;</span> other.min_root<span style="color:#f92672">-&gt;</span>value) {
					min_root <span style="color:#f92672">=</span> other.min_root;
				}
			}
			<span style="color:#75715e">// release 
</span><span style="color:#75715e"></span>			other.min_root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
			n <span style="color:#f92672">+=</span> other.n;
			other.n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		}

		fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> extract_minimun() {
			<span style="color:#66d9ef">auto</span> ret <span style="color:#f92672">=</span> min_root;
			<span style="color:#66d9ef">if</span> (ret) {
				<span style="color:#75715e">// 移动所有子节点到根表
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">auto</span> child <span style="color:#f92672">=</span> ret<span style="color:#f92672">-&gt;</span>child;
				<span style="color:#66d9ef">if</span> (child) {
					<span style="color:#66d9ef">auto</span> left <span style="color:#f92672">=</span> ret<span style="color:#f92672">-&gt;</span>left;
					<span style="color:#66d9ef">auto</span> child_left <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>left;
					left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> child;
					child<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> left;
					ret<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> child_left;
					child_left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> ret;
				}
				<span style="color:#75715e">// 从根表中删除最小节点
</span><span style="color:#75715e"></span>				ret<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> ret<span style="color:#f92672">-&gt;</span>right;
				ret<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> ret<span style="color:#f92672">-&gt;</span>left;
				<span style="color:#75715e">// 根据情况调整
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
					min_root <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
				}
				<span style="color:#66d9ef">else</span> {
					min_root <span style="color:#f92672">=</span> ret<span style="color:#f92672">-&gt;</span>left;
					consolidate();
				}
				ret<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
				ret<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
				ret<span style="color:#f92672">-&gt;</span>child <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
				n<span style="color:#f92672">--</span>;
			}
			<span style="color:#66d9ef">return</span> ret;
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">decrease_value</span>(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value) {
			<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;</span> new_value) {
				<span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>exception(<span style="color:#e6db74">&#34;new value should smaller than old value&#34;</span>);
			}
			node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> new_value;
			<span style="color:#66d9ef">auto</span> parent <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>parent;
			<span style="color:#75715e">// 父节点大于当前节点，需要断开、递归向上断开
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (parent <span style="color:#f92672">&amp;&amp;</span> parent<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>value) {
				cut(node, parent);
				cascade_cut(parent);
			}
			<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;</span> min_root<span style="color:#f92672">-&gt;</span>value) {
				min_root <span style="color:#f92672">=</span> node;
			}
		}

		<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete_node</span>(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> node) {
			decrease_value(node, min_root<span style="color:#f92672">-&gt;</span>value);
			extract_minimun();
		}

		<span style="color:#75715e">// 实用打印函数
</span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> get_root_list() {
			std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> ret;
			ret.push_back(min_root);
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> root <span style="color:#f92672">=</span> min_root<span style="color:#f92672">-&gt;</span>right
				; root <span style="color:#f92672">!=</span> min_root
				; root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right) {
				ret.push_back(root);
			}
			<span style="color:#66d9ef">return</span> ret;
		}

		<span style="color:#75715e">// 实用打印函数
</span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> get_child_list(fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> parent) {
			std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> ret;
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>parent<span style="color:#f92672">-&gt;</span>child)
				<span style="color:#66d9ef">return</span> ret;
			ret.push_back(parent<span style="color:#f92672">-&gt;</span>child);
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> child <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>child<span style="color:#f92672">-&gt;</span>right
				; child <span style="color:#f92672">!=</span> parent<span style="color:#f92672">-&gt;</span>child
				; child <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>right) {
				ret.push_back(child);
			}
			<span style="color:#66d9ef">return</span> ret;
		}

		<span style="color:#66d9ef">friend</span> std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> o, fibo_heap<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> heap) {
			o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&lt;&lt;&lt;&lt;&lt;print fibo heap&gt;&gt;&gt;&gt;&gt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;nums: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> heap.n <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">auto</span> root_list <span style="color:#f92672">=</span> heap.get_root_list();
			std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>fibo_heap_node<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> node_queue;
			o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;root list: &#34;</span>;
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> t : root_list) {
				o <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
				<span style="color:#66d9ef">auto</span> childs <span style="color:#f92672">=</span> heap.get_child_list(t);
				<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> t : childs) {
					node_queue.push(t);
				}
			}
			o <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>node_queue.empty()) {
				o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ===== &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
				<span style="color:#66d9ef">for</span> (size_t nums <span style="color:#f92672">=</span> node_queue.size(); nums <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>; nums<span style="color:#f92672">--</span>) {
					<span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> node_queue.front();
					node_queue.pop();
					o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;node: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; parent is: &#34;</span> 
						<span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>parent<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
					<span style="color:#66d9ef">auto</span> childs <span style="color:#f92672">=</span> heap.get_child_list(node);
					<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> t : childs) {
						node_queue.push(t);
					}
				}
			}
			o <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&lt;&lt;&lt;&lt;&lt;print over&gt;&gt;&gt;&gt;&gt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
			<span style="color:#66d9ef">return</span> o;
		}
	};

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> lyc_algorithm;
	fibo_heap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> fibo_heap_test;
	fibo_heap_test.insert(<span style="color:#ae81ff">1</span>);
	fibo_heap_test.insert(<span style="color:#ae81ff">2</span>);
	fibo_heap_test.insert(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>);
	fibo_heap_test.insert(<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>);
	fibo_heap_test.insert(<span style="color:#ae81ff">0</span>);
	fibo_heap_test.insert(<span style="color:#ae81ff">12</span>);
	<span style="color:#66d9ef">auto</span> mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	fibo_heap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> other;
	other.insert(<span style="color:#ae81ff">233</span>);
	other.insert(<span style="color:#ae81ff">666</span>);
	other.insert(<span style="color:#ae81ff">255</span>);
	other.insert(<span style="color:#f92672">-</span><span style="color:#ae81ff">1234</span>);
	fibo_heap_test.merge(other);
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	mini <span style="color:#f92672">=</span> fibo_heap_test.extract_minimun();
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;extract minimum: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> mini<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">delete</span> mini;
	<span style="color:#66d9ef">auto</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> fibo_heap_node<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>);
	fibo_heap_test.insert(node);
	fibo_heap_test.insert(<span style="color:#ae81ff">0</span>);
	fibo_heap_test.insert(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>);
	fibo_heap_test.insert(<span style="color:#ae81ff">6</span>);
	fibo_heap_test.insert(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>);
	fibo_heap_test.insert(<span style="color:#ae81ff">23</span>);
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> fibo_heap_test.extract_minimun()<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	fibo_heap_test.decrease_value(node, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> fibo_heap_test.get_minimum() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="后记">后记</h1>
<ul>
<li>如果你是按顺序阅读的，那么读完树这一章，你应该会有一个疑问，为什么这部分内容算在了算法里面。是的，虽然这部分内容看起来更像是数据结构，但是其实这些数据结构的本质思想，已经不再是简简单单的链表、队列、动态表这些，而是更高级的思想。比如如何利用二分法、均摊、附加标记等方式或思路，大幅度提高某些场景下的运行效率。</li>
<li>更幸运的是，大部分情况下，我们可以在很多语言中直接找到基于这些数据结构的实用工具。尤其是红黑树、B树，他们俩几乎构成了常用平衡搜索树的绝大部分江山。是我们进入$O(logn)$的最佳帮手。</li>
</ul>
<h1 id="在写作本章节时记录的博客问题">在写作本章节时记录的博客问题</h1>
<ul>
<li>在使用mathjax的\$\$对儿中，如果直接写[x]，则会显示出来一个<input checked="" disabled="" type="checkbox"> ，如果想要正常显示[x]，需要写为\\[x\\]。
<ul>
<li>markdown的转义。。。有的时候真的令人无语。</li>
</ul>
</li>
</ul>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://www.lyclife.com/tags/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/">算法系列</a>

  <a class="tag tag--primary tag--small" href="https://www.lyclife.com/tags/%E6%96%BD%E5%B7%A5%E4%B8%AD/">施工中</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E5%85%AB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" data-tooltip="算法导论其八：动态规划和贪心算法">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E9%A5%A5%E8%8D%92linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" data-tooltip="饥荒Linux服务器搭建教程">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2022 李奕成. All Rights Reserved 
  </span>
  <a href="https://beian.miit.gov.cn/#/Integrated/index" target="blank">吉ICP备2021004867</a>
  
  <div>
    <img src="https://www.lyclife.com/images/beian.png">
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502045148" target="blank">京公网安备11010502045148</a>
  </div>
  
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%85%B6%E5%85%AB%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" data-tooltip="算法导论其八：动态规划和贪心算法">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://www.lyclife.com/2021/08/%E9%A5%A5%E8%8D%92linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" data-tooltip="饥荒Linux服务器搭建教程">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://www.lyclife.com/images/author.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">李奕成</h4>
    
      <div id="about-card-bio">每天都是最好的一天</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        京投 软件研发
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        北京·朝阳
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://www.lyclife.com/images/background/bridge_linjiangmen.jpg');"></div>
    
  


    
<script src="https://www.lyclife.com/scripts/jquery360/jquery.min.js"></script>

<script src="https://www.lyclife.com/scripts/highlight.min.js"></script>


<script src="https://www.lyclife.com/scripts/fancybox-2.1.7/jquery.fancybox.min.js"></script>


<script src="https://www.lyclife.com/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      CommonHTML: { linebreaks: { automatic: true } },
      tex2jax: { inlineMath: [ ['$', '$'], ['\\(','\\)'] ], displayMath: [ ['$$','$$'], ['\\[', '\\]'] ], processEscapes: false },
      messageStyle: 'none'
    });
  </script>



    
  </body>
</html>

