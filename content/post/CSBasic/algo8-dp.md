---
title: "算法导论其八：动态规划和贪心算法"
date: 2021-08-27T10:31:04+08:00
categories:
- 计算机科学与技术
- 算法
tags:
- 算法系列
thumbnailImagePosition: left
thumbnailImage: /images/thumbnail/algorithm.jpg
math: true
---
动态规划可以简单的理解为带备忘录的搜索。相较于搜索，动态规划通过列出状态转移方程和边界条件，通常能够非常简明的计算出结果。贪心算法也在本章。
<!--more-->
## 动态规划
### 概述
1. 动态规划并没有一个放诸四海皆准的公式。但是总而言之，它可以分为以下几个步骤进行设计。
    1. 描述最优解的结构（也是最考验思维的一步，最优解由哪些值计算得出）
    2. 递归定义最优解的值（状态转移方程）
    3. 自底向上的计算最优解所需要的值
    4. 由计算出的各个值构造出最终结果
2. 优化：普通的动态规划并没有本质上比搜索强太多，即不一定能降低复杂度，可能只是常数上的一个改变。动态规划实际也有很多优化技巧。
### 最优子结构
1. 定义：如果一个问题的最优解中，包含了子问题的最优解，就称该问题具有最优子结构。
    - 具备最优子结构，是使用动态规划，贪心算法的**必要**条件。
    - 最优子结构并不一定是直接就能看出来的，常常需要进行一定的构造，将原问题巧妙的描述。
1. 寻找最优子结构的一些思路：
    - 问题具有选择性，一个位置的选择会得到一个或多个需要解决的子问题。
    - 先假设已经获得一个导致最优解的选择
    - 确定在这种选择下，会发生哪些子问题，如何描述子问题所代表的搜索空间
    - 可能存在具有多种子问题的情况，需要计算多个不同种类的子问题，来共同决定一个原问题的最优解
### 重叠子问题
1. 定义：如果一个问题的求解过程中，可以反复求解完全相同（参数上下文）的子问题，而不是总在搜索全新的子问题，那么就说明该问题具有重叠子问题。
    - 是重叠子问题，是动态规划可行的**必要条件**。
    - 和分治法的对比：分治法总是在每一步产生全新的子问题。
### 备忘录写法
1. 动态规划的一种变形，既具有大体上等价于动态规划的效率，又采用了自顶向下的写法（更类似于搜索）。
1. 写法：就是针对当前输入参数做问题记录，对于完全相同的输入参数，直接返回上一次的计算结果。
### 树上DP
1. 动态规划的一种变形，为了适应题目中子问题之间的树结构。一般会综合其他树算法（如LCA）、动态规划（如背包DP）算法进行考察。
2. 一般写法：从根开始DP，对子树递归返回一个DP数组，在根位置计算状态转移
3. 参考:[OI Wiki 树形 DP](https://oi-wiki.org/dp/tree/)

### 优化
1. 空间优化：当你编程的时候发现，动态规划的状态存储数据结构中，有那么几个维度，只受到少数状态值（或者是最近几次状态值的影响），那么就可以进行空间优化。一般可以将数据结构降低一个$n$的指数级别。
    - 例如：$f(i,j)=max_{0<j<n}\\{f(i-1,j)+h_{\mathrm{某种代价}}(i,j)\\}$。这里面，i所在的维度，显然没有存储的必要，在可以的情况下应当予以删除。
    - 优化不需要过早，为了思路清晰，空间多一些一般无所谓。
2. 时间优化：这是动态规划提升难度的地方。计划在后续的系列中，结合实际题目进行更新吧。
### 例子
#### 装配线调度
<center><img src='/images/algoSeries/dp-pipeline.svg'/></center>
</br>

1. 问题描述：
    - 在工厂内经常有装配线用于组装一个产品，一条装配线上有多个装配站，当一个产品经过一个装配线上的所有装配站后就可以出厂了。设装配线编号为$i$，设第$i$条装配线上的第$j$个装配站为$S_{i,j}$。不同装配线上的相同位置的装配站，功能相同。即$S_{1,j}$和$S_{2,j}$功能相同。将装配站$S_{i,j}$的装配用时记为$a_{i,j}$。产品进入第$i$条装配线的时间为$e_i$，离开的时间为$x_i$。
    - 不同的装配站速度可能完全不一样，即使他们是同一顺位的。而且正常情况下，装配线上的产品是不会变更装配线的，但是如果希望加快装配速度，则可以更换。将产品从$S_{i,j}$移走的时间为$t_{i,j}$。
    - 请问一个产品从开始装配到结束，最快能多快呢？（方便起见，本文接下来的讨论中，装配线数量只有两个）
1. 暴力解法：遍历所有的$2^n$种装配站的组合，计算每一种的用时。复杂度$O(2^nn)$。$j=1,2,....,n$
1. 思考步骤：
    1. 描述最优解的结构：考虑产品从起始点到装配站$S_{i,j}$的最快路线$f(S_{i,j})$。按顺序遍历所有的装配站即可。
    1. 状态转移方程：$f(S_{i,j}) \gets h(S_{1,j-1},S_{2,j-1})$。更具体的来说，$f(S_{1,j})=min(f(S_{1,j-1})+a_{1,j},\ f(S_{2,j-1})+t_{2,j-1}+a_{2,j})$。
    1. 自底向上计算：给出边界值$f(S_{1,1}) = a_{1,1} , \ f(S_{2,1}) = a_{2,1}$。
    1. 最终结果：$min(f(S_{1,n}), \ f(S_{2,n}))$。
1. 额外的话：
    1. 描述最优解的结构，这是非常考验算法能力的一步。说太多的方法论都是空话，这个东西就是多看多练就好了。
    1. 有一种值得一试的思路，就是从递归的反向思维出发。正常是计算当前的用时，然后递归调用接下来去往哪个装配站。而动态规划的解法恰恰相反，是从当前装配站的来源来考虑。
#### 矩阵链乘法
1. 描述：给定$n$个要相乘的矩阵构成的序列$<A_1,A_2,...,A_n>$。计算乘积，$A_1 A_2 \cdots A_n$。如何让计算尽量快。
    - 更快的计算：在这里不考虑对矩阵乘法的专门优化。只考虑一个最优的矩阵乘顺序。即如何添加括号，使得总的乘法计算数量尽量小。
1. 暴力解法：将矩阵乘序列分为两个部分，最后计算两部分的乘积。递归的，暴力进行这种划分方式的搜索。你可以试着推导一下这个的复杂度，简单来说，是指数级别的，$\Omega(2^n)$
1. 思考步骤：
    1. 描述最优解结构：对于长度为$l$的矩阵乘序列，$A_i A_{i+1} \cdots A_{i+l} $序列，其最优解包含于$A_i A_{i+1} \cdots A_k \cdot A_{k+1} \cdots A_{i+l}$。遍历$k \in (i,i+l)$，即可获得最优解。
    1. 状态转移方程。$f(A,i,i+l) = min_{i<k<i+l-1}\\{$
        $f(A,i,k)+f(A,k+1,i+l)$
        $+ROW(A_i)*COL(A_k)^2*COL(A_{i+l})\\}$
    1. 自底向上计算：给出边界值，即所有的$l=1$的矩阵乘序列，就是两个矩阵相乘所需要的乘法数量，先算出来这部分。然后分别遍历$l,k$。
    1. 最终结果：$f(A,1,n)$
1. 额外的话：
    1. 本题的动态规划思路和暴力思路看起来非常相近，但是是有本质区别的。从另一个角度来看，动态规划利用了重叠区间的共享信息。使得最终的时间复杂度达到了$\Theta(n^2)$。
#### 最长公共子序列
1. 描述：
    - 两个字符串，形如字符串a："ABCDEFGXYZ",字符串b："AZDZGZXZYZUC"。子序列指的是字符串中部分不重复的字符组成的新字符串，非要形式化的话，对原串$<a_1 a_2 \cdots a_n>$，取序列$1 \le i_1 < i_2 < \cdots < i_{k-1} < i_k \le n$，其中$k \in [0,n]$，则原串的一个子序列为$<a_{i_1} a_{i_2} \cdots a_{i_{k-1}} a_{i_k}>$。
    - 最长公共子序列LCS（Longest Common Subsequence）就是求出两个字符串，甚至是多个字符串之间，最长的且相等的子序列。
    > 子串的要求是下标序列$i_1,i_2,\cdots,i_k$必须连续。注意子序列和子串的区分。
1. 暴力解法：枚举二者所有的子序列，从最长的开始比较是否有相等的情况。仅仅是枚举子序列就已经达到$O(2^n)$了哦。
1. 思考步骤：
    1. 描述最优子结构：令$f(i,j)$代表第一个字符串$a$包含在范围$<a_1 \cdots a_i>$内的子序列，和第二个字符串$b$包含在范围$<b_1 \cdots b_j>$。
    1. 状态转移方程：
        - 如果$a_i = b_j$：则$f(i,j)=f(i-1,j-1)+1$
        - 否则$a_i \ne b_j$：则$f(i,j)=max\\{f(i-1,j),f(i,j-1)\\}$
    1. 自底向上计算：边界情况为$f(1,1)$，分别遍历$i,j$。
    1. 最终结果：$f(length(a),length(b))$。
1. 额外的话：
    1. 从这里，我们发现，动态规划的状态转移方程，可能有多种情况，不同情况之间的状态转移可能完全不同，有的可能直接算出结果，有的需要进行$min$，$max$等操作。
#### 最优二叉查找树
<center><img src='/images/algoSeries/dp-bestAVL.svg'/></center>
</br>

1. 描述：
    - 虽然通过一定的算法，我们能够构造出平衡的二叉搜索树，但是这种搜索树的搜索效率并不是最优的。假设我们需要简单的填鸭式翻译一篇文章，从中文到英文，那么我们希望频率出现最高的词汇，相对的出现在二叉搜索树的顶端，这样能够尽量减少搜索时的访问次数。因此我们需要建立的就是一棵最优二叉搜索树。
    - 形式化地，给定一个由$n$个互异的关键字组成的序列$K=<k_1,k_2,\cdots,k_n>$，且关键字有序，即$k_1 < k_2 < \cdots < k_n$。由于某些搜索的值，可能不存在于关键字序列中，因此实际上我们需要使用一套虚拟关键字序列$D=<d_0,d_1,d_2,\cdots,d_n>$，其中$d_0$代表所有小于$k_1$的值，$d_n$代表所有大于$k_n$的值。而对于$d_i \in \\{d_1,\cdots,d_{n-1}\\}$，虚拟键$d_i$代表所有位于$k_i$，$k_{i+1}$之间的值。使用关键字序列$K$，$D$建立的搜索树中，每个关键字$k_i$是一个内部节点，每个虚拟关键字$d_i$是一个叶子节点。设找到$k_i$的概率为$p_i$，找到$d_i$的概率为$q_i$，显然有$\sum{p_i}+\sum{q_i}=1$。
    - 假设搜索代价和节点深度有关，则对于一棵二叉搜索树$T$，一次搜索的期望代价为：$E[T] = \sum_{i=1}^{n}(depth_T(k_i)+1)p_i + \sum_{i=1}^{n}(depth_T(d_i)+1)q_i$ 
    </br>&emsp;&emsp;&emsp;$= 1 + \sum_{i=1}^{n}depth_T(k_i)p_i + \sum_{i=1}^{n}depth_T(d_i)q_i$
    - 如何排列$k_i$使得期望代价最小，就是寻找最优二叉搜索树。
1. 暴力解法：暴力生成所有可能的二叉搜索树的结构，计算搜索期望。这种树的数量是指数级别的，别想了。
1. 思考步骤：
    1. 描述最优子结构：
        - 描述一个最优二叉搜索树的最优子结构，没有比子树更合适的描述方式了。任意一个子树必定包含连续范围内的关键字$k_i,\cdots,k_j$，而且此时叶子也恰好为$d_{i-1},\cdots,d_j$。假设此时有一个最优二叉搜索树的子树$T'$，包含$k_i,\cdots,k_j$，那么子树下，取得$k_i,\cdots,k_j$中部分元素的子树（就是子树$T'$的子树）也一定是最优的。（不然就有另一种生成方式了）。
        - 设$f(i,j)$代表关键字$k_i,\cdots,k_j$所生成的树中，具有最小期望代价的情况。
    1. 状态转移方程：
        - 当$i=j+1$，$f(i,j)=q_{i-1}$
        - 当$i<j+1$，$f(i,j)=min_{i\le t \le j}\\{f(i,t-1)+f(t+1,j)+w(i,j)\\}$
            - 其中$w(i,j)=\sum_{t=i}^{j}p_t+\sum_{t=i-1}^{j}q_t$，即该区间上所有的关键字、虚拟关键字的概率总和（深度+1，意味着所有概率都增加一份）
    1. 自底向上计算：遍历$i,j$
    1. 最终结果：$f(1,n)$
1. 额外的话：在这道题目中，问题的关键在于理解状态转移方程中$i=j+1$的情况。这代表着当前状态存储的是一个单一的虚拟关键字（即叶子节点）。这是本题的边界情况。
    - 很多边界情况都考验对最优子结构在边界情况下的理解程度。如果边界理解不正确，常常不能计算出正确的结果。
## 贪心算法
### 概述
- 贪心算法，往往作为一些算法中的策略出现。它的本意就是无脑的选择当前状态下，最优的策略。并且这种最优结果最终，也等价于整体最优。
- 经常会下意识的进行一些贪心策略的应用。但是需要注意的是，至少要证明一下贪心策略是有效且正确的。
- 设计思路：
    1. 和动态规划类似的：描述最优子结构、设计出一个递归解
    1. 证明在递归的任意阶段，只有一个子问题（即只有多种选择中的固定的一种）会保留下来
    1. 将递归算法转换为迭代算法
### 例子
#### 活动选择问题
- 描述：一个活动表上写着各类活动的安排，这些活动具有起始时间$0 < s_i$，终结时间$e_i$。这些活动之间可能有时间上的重叠。要求计算从起始时刻开始，到某一给定时间$t$为止，能进行的最多的活动数量。
- 贪心策略：每一次选择在当前时刻之后开始且**最早结束**的一个活动，并更新当前时刻。
#### 哈夫曼编码
<center><img src='/images/algoSeries/huffman.svg'/></center></br>

- 描述：
    - 哈夫曼（Huffman）编码是一种经典的数据压缩技术。这里仅针对字符串数据做例子。哈夫曼编码使用一张字符统计表来统计各类字符出现的次数、频率。随后，算法将使用二进制字符编码，将每一个字符，转换为一个固定且唯一的二进制串来表示。比如将字符$a$转换为二进制串$(000)_2$，$b$转换为$(001)_2$。
    - 如何进行二进制串的选择，是决定数据压缩效率的关键。采用可变长度的编码显然要优于采用固定长度编码。即对频率高的字符，转换为长度较短的二进制串。（回想一下最优二叉查找树，但是这里不需要考虑搜索失败的情况，编码一定存在）
    - 前缀编码（prefix code），即在编码表中，没有任何一个编码，是其他某一个编码的前缀。因此可以唯一的确定
    - 哈夫曼编码算法，就是一种产生最优前缀编码的方式。
- 贪心的构造策略：假设对一个有$n$个字符的字符串构造
    - 统计每个字符的频度，
    - 用最小优先队列存储节点，节点包含域：字符和它的频度（频度作为优先队列的排序值）
    - 每一次出队两个节点，并将它们合并，频率取二者之和，再插回队列（这一步实际在不断创建子树）
    - 出队$n-1$次后，最后第$n$次出队，得到最优前缀编码树。
    > 最小优先队列，可以理解为一个最小堆（实际上也往往是这么实现的），每一次出队都会弹出当前队列中最小的值。
- 哈夫曼编码的使用
    - 在得到最优前缀编码树之后，可以将每条路径赋值，一般向左子树的路径分配0，向右子树的分配1。从根节点到达叶子节点（待编码字符）的路径上所依次经过的值，就是它的二进制编码。
### 扩展阅读：“拟阵”
1. 定义：一个拟阵是满足以下条件的一个序对$M=(S,\mathscr{l})$
    1. $S$是一个有穷非空集合
    2. $\mathscr{l}$是$S$的一个非空子集族，称为$S$的独立子集，使得如果$B \in \mathscr{l}$且$A \subset B$，那么$A \in \mathscr{l}$。此时也称$\mathscr{l}$是遗传的。注意$\emptyset \in \mathscr{l}$。
    3. 如果$A \in \mathscr{l}$，$B \in \mathscr{l}$，且$|A|<|B|$，则有某个元素$x \in B-A$使得$A \cup \\{x\\} \in \mathscr{l}$。我们称$M$满足交换性质。
1. 用拟阵描述问题的例子：
    1. 图的拟阵$M_G=(S_G,\mathscr{l}_G)$，对应无向图$G=(V,E)$
        - 集合$S_G$代表边集$E$
        - 如果$A$是$E$的子集，则$A \in \mathscr{l}_G$当且仅当$A$是无回路的。即子图$G_A=(V,A)$构成一个森林
1. 拟阵和贪心算法的关系：
    1. 很多适合用贪心算法的问题，都可以归结为一个加权拟阵问题。即给定一个加权拟阵$M=(S,\mathscr{l})$，求解一个具有最大可能权值$w(A)$的子集$A \in \mathscr{l}$。 
1. 拟阵和任务调度问题：
    1. 描述：在单核处理器上对若干个消耗单位时间的任务进行最优调度。每一个任务有一个截止期限和超时惩罚。
        - 每个任务只需要单位时间。一个最优调度可以直观的认为就是任务集合的一个全排列。
        - 形式化：包含$n$个单位时间任务的集合$S=\\{a_1,a_2,\cdots,a_n\\}$。期限$d_1,d_2,\cdots,d_n$，任务$a_i$要求在$d_i$时间之前完成。惩罚值$w_1,w_2,\cdots,w_n$。
        - 求解最小的总惩罚
    1. 贪心策略：早开始的任务优先（因为如果超时在前，另一个任务在后，那么显然将超时延后执行也没有坏处）
    1. 从拟阵角度思考：
        - 需要做的就是寻找一个可以通过某种调度不产生超时情况的任务的集合$A$。并称这样的任务集合是独立的。
        - 此时的$(S,\mathscr{l})$就构成了一个拟阵。