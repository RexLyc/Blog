---
title: "边学边用linux-内核篇"
date: 2024-03-15T11:14:25+08:00
categories:
- 计算机科学与技术
- 操作系统
tags:
- 操作系统系列
- 命令行
- 滚动更新
thumbnailImagePosition: left
thumbnailImage: /images/thumbnail/linux.jpg
draft: true
---
本文记录一些Linux内核原理，内核数据结构，内核算法，内核参数相关的知识
<!--more-->
> 本章节内容也可能会在本系列的其他文章中出现。主要是为了方便集中查阅。

## 内核参数
一些内核参数是可以配置的，可以通过如下指令进行查看
```bash
# 查看内核参数
sysctl -A 
```

一些比较重要的参数
| 参数名 | 内容 | 参数值（举例） | 含义 |
| --- | --- | --- | --- |
| net.ipv4.tcp_rmem、net.ipv4.tcp_wmem | tcp接收、发送缓冲区大小 | 4096 87300 6291456 | 最小4k、默认87k、最大6M |

## 内核数据结构
### RCU
RCU（Read-Copy Update）是数据同步的一种方式，在当前的Linux内核中发挥着重要的作用。RCU主要针对的数据对象是链表，目的是提高遍历读取数据的效率，为了达到目的使用RCU机制读取数据的时候不对链表进行耗时的加锁操作。这样在同一时间可以有多个线程同时读取该链表，并且允许一个线程对链表进行修改（修改的时候，需要加锁）。RCU适用于需要频繁的读取数据，而相应修改数据并不多的情景，例如在文件系统中，经常需要查找定位目录，而对目录的修改相对来说并不多，这就是RCU发挥作用的最佳场景。

实现上顾名思义，RCU(Read-Copy Update)，就是“读，拷贝更新”，再直白点是“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对“读多写少”的共享数据的同步机制。其实就是双缓冲。

在RCU的实现过程中，我们主要解决以下问题：
1. 在读取过程中，另外一个线程删除了一个节点。删除线程可以把这个节点从链表中移除，但它不能直接销毁这个节点，必须等到所有的读取线程读取完成以后，才进行销毁操作。RCU中把这个过程称为宽限期（Grace period）。
2. 在读取过程中，另外一个线程插入了一个新节点，而读线程读到了这个节点，那么需要保证读到的这个节点是完整的。这里涉及到了发布-订阅机制（Publish-Subscribe Mechanism）。需要用内存屏障的方式，保证读取的指令排在修改之后。
3. 保证读取链表的完整性。新增或者删除一个节点，不至于导致遍历一个链表从中间断开。但是RCU并不保证一定能读到新增的节点或者不读到要被删除的节点。

相关API
```c
rcu_read_lock()
rcu_read_unlock()

synchronize_rcu()

rcu_assign_pointer()
rcu_dereference()
```

RCU的设计，是绝大部分为读而只有极少部分为写的情况下。对于多个写者，或者无法容忍RCU写入时内存消耗的情况，需要再做单独的优化。

## 内核算法

## 内核原理 

## 参考
1. [知乎-陈硕：Linux 中每个 TCP 连接最少占用多少内存？](https://zhuanlan.zhihu.com/p/25241630)
2. [Linux 内核：RCU机制与使用](https://www.cnblogs.com/schips/p/linux_cru.html)