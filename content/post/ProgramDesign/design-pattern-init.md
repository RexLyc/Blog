---
title: "设计模式开坑篇"
date: 2021-08-04T10:56:42+08:00
categories:
- 计算机科学与技术
- 设计模式
tags:
- 系列开坑
- 设计模式
- 施工中
---
软件行业发展到现在，大部分需求场景下，优秀的开发模式已有定论。本系列结合场景和代码，总结常用设计模式。
<!--more-->.
# 为什么要看设计模式
- 虽然设计模式经常被人吐槽，但实际上学一点设计模式本质上只是想借鉴前人经验。
- 不仅是代码复用，更要体会经验复用，分解问题的方式方法。
# 常用设计模式速览
1. 创建型：如何更优雅的创建对象
    - 单例模式（Singleton）：一个类型在程序生命周期内只有一个实例
    - 抽象工厂（Abstract Factory）：提供一个接口用于创建相关对象的工厂，是工厂的工厂
    - 工厂方法（Factory）：提供创建实例的接口，由具体的子类工厂决定具体实例化的类型
    - 生成器（Builder）：将复杂对象的构建和表示分离，适合用于类型内部元素组合方式多变，而每个元素构造方式相对稳定的情况
    - 原型（Prototype）：用于创建重复的对象，并保证性能。即为创建代价较高的对象，提供克隆方法。
2. 结构型：如何更优雅的扩展功能、精简代码
    - 组合模式（Composite）：部分整体模式，对象内部有同类型对象的集合，例如展开成树状结构的表达式。
    - 外观（Facade）：优化接口，降低外部使用模块的复杂度。可以用于封装多个类。项目中期优化使用。
    - 代理（Proxy）：增加中间层，为其他对象提供接口以提供对当前被代理对象的访问。一般针对一个类。
    - 适配器（Adaptor）：为两个已有的不兼容模块间的接口建立连接，使得能够共同工作。非必要不应使用适配器模式，而应当进行重构。项目后期兼容开发。
    - 装饰器（Decorator）：允许向一个现有的对象的某个接口添加新的扩展功能，而不改变已有结构。由一个抽象类实现一个接口，可以一直扩展下去。
    - 桥接器（Bridge）：把抽象和实现解耦。将多变的部分单独抽象为接口，在实体类中进行使用。由一个抽象类持有一个接口。项目前期设计。
    - 享元（Flyweight）：尝试重用现有的同类对象，如果无法匹配则创建新的对象。
    - 过滤器模式（Filter）：一个接口继承体系内，用不同实现过滤同一组对象。过滤操作可以组合成复杂的语义。
3. 行为型：如何更优雅的完成一些操作
    - 迭代器（Iterator）：提供一个获取迭代器的接口，顺序访问集合对象元素。
    - 观察者（Observer）：对存在一对多依赖关系的情况，保管相关依赖对象的集合，变更属性则通知依赖它的对象。
    - 模板方法（Template）：允许重写部分方法，但这些方法的调用将会以抽象类中定义的逻辑进行。
    - 命令（Command）：数据驱动，将命令包裹在对象中进行传递，调用对象负责寻找合适的处理对象，将命令传递过去。调用者→命令→接收者，即调用者实际保存若干命令，命令中封装对接收者的实际调用。
    - 状态（State）：对象内部保存一个状态对象（每种状态需要实现不同状态下的行为，并且行为会变更依赖对象），根据不同状态变更行为。用来避免过多条件语句。表现为类的行为是受状态控制而变化。可以优雅的实现状态机。
    - 策略模式（Strategy）：创建统一接口下表示各种策略的对象，使之可被替换。表现上是一个类中接口的行为可以动态变化、替换。
    - 职责链（Chain ofResponsibility）：也叫责任链，将请求的发送者和接收者解耦，多个对象都有可能接收请求，直到有对象处理为止。
    - 中介者（Mediator）：提供一个中介类处理不同类之间的通信，降低通信的复杂性。
    - 访问者（Visitor）：针对一些易变且和对象类型无关的操作，在被访问的类里放一个对外接收访问者的接口，将数据结构和数据操作分离。
    - 解释器（Interpreter）：评估语言的语法或表达式，用于实现简单文法。（终结符表达式、非终结符表达式）
    - 备忘录（Memento）：保存对象的状态，以便在需要的时候恢复对象。由备忘录对象、备忘录管理对象构成。
    - MVC：Model代表存取数据的对象，View包含可视化内容，Controller控制数据双向流动
4. 其他：
    - 空对象（Null Object）：取代空对象实例检测，反应一种不做任何动作的子类情况。
# 七大原则
1. 开闭原则：允许扩展，禁止修改。
2. 单一职责原则：一个类只做一件事情。
3. 依赖倒转原则：高层模块不应依赖底层模块。即开发应当面向抽象（接口），而不针对具体实现。
4. 迪米特（最小知识原则）：高内聚，低耦合。一个对象应当尽量减少自己的依赖类型、减少和自己有耦合关系的类型。提升模块之间的独立程度。
5. 里氏代换原则：任何可以使用父类的地方，均应可以使用子类。
6. 接口隔离原则：接口应当尽量分化、细化，不应当强迫用户实现一些不会使用到的接口。互相依赖应当建立在最小的接口集合上。
7. 组合/聚合复用原则：尽量使用组合和聚合少使用继承来完成代码复用。
# 术语
1. 耦合性：指模块之间的信息、参数的依赖程度。
2. 内聚性：和耦合相对，指功能相关的程序组合成一个模块的程度。
# 图例
- 实现
<center><img src="/images/algoSeries/ImplementUML.svg" ></center>

- 继承
<center><img src="/images/algoSeries/ExtendUML.svg" ></center>

- 组合
<center><img src="/images/algoSeries/CompositionUML.svg" ></center>

- 聚合
<center><img src="/images/algoSeries/AggregationUML.svg" ></center>

- 依赖
<center><img src="/images/algoSeries/ImplementUML.svg" ></center>

- 关联
<center><img src="/images/algoSeries/ImplementUML.svg" ></center>

# 参考资料
《Head First设计模式》

[24种设计模式大全](https://blog.csdn.net/yanlin813/article/details/52664805)

[设计模式-菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

[桥接模式、外观模式、适配器模式的区别](https://www.cnblogs.com/peida/archive/2008/08/01/1257574.html)